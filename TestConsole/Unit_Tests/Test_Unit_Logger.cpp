#include <stdarg.h>     /* va_list, va_start, va_arg, va_end */
#include "Test_Unit_Logger.h"

Test_Unit_Logger::Test_Unit_Logger()
{
    //ctor
}

Test_Unit_Logger::~Test_Unit_Logger()
{
    //dtor
}


void Test_Unit_Logger::autonomous_logger(int threadNum)
{// a negative threadNum param means the call has been spawn from the main thread.
    Common::SinkFs log;
    //
    log.SectionOpen("autonomous_logger", 0);
    for(int c=0; c<10; c++)
    {
        std::string threadLabel("from inside autonomous_logger:: thread number ");
        std::string * converter = Common::StrManipul::intToString( threadNum);
        threadLabel += *converter;
        delete converter;
        log.SectionTrace( threadLabel, 0);
    }
    log.SectionClose();
}// autonomous_logger


void Test_Unit_Logger::singleton_logger(int threadNum)
{// a negative threadNum param means the call has been spawn from the main thread.
    // no log instance -> Singleton
    Process::LogWrappers::SectionOpen("singleton_logger", 0);
    for(int c=0; c<10; c++)
    {
        std::string threadLabel("from inside singleton_logger:: thread number ");
        std::string * converter = Common::StrManipul::intToString( threadNum);
        threadLabel += *converter;
        delete converter;
        Process::LogWrappers::SectionContent( threadLabel.c_str() , 0);
    }
    Process::LogWrappers::SectionClose();
}// singleton_logger



// TODO goes in Process::Log_Wrappers
// TODO let the prototype take std::string* and delete --------------------(V)
// TODO let the prototype use a StringBuilder to concatenate the input ----(V)
int Test_Unit_Logger::logFromMultipleStrings(int howMany_params, ...)
{// takes an unspecified number of std::string and concatenates them, with  blank in between.
    Process::LogWrappers::SectionOpen("logFromMultipleStrings", 0);
    int loopCounter;
    std::string * val;// the choosen data-type; string* generated by conversion of vars to be logged.
    va_list v_list;// va_list is the data-type of the unspecified parameters
    va_start( v_list, howMany_params);// va_start is the macro to open the set.
    Common::StringBuilder sb( 100 * howMany_params);// estimate 100 chars per param; auto.
    sb.append( std::string("composition state : "));
    for( loopCounter=0; loopCounter<howMany_params; loopCounter++)
    {// the macro va_arg can be queried from zero to  to need to howMany_params-1.
        val = va_arg( v_list, std::string* );// get the current one of the params
        sb.append( *val);// use the StringBuilder to append
        sb.append( std::string("  "));
        delete val;// delete the original. TODO test
    }
    va_end( v_list);// macro to close the set.
    //
    Process::LogWrappers::SectionContent( sb.str().c_str() , 0);
    //std::cout<< "\n\t composition state : "<< sb.str(); // DBG
    Process::LogWrappers::SectionClose();
    // ready.
    return howMany_params;// return how many params have been given
}// logFromMultipleStrings


void Test_Unit_Logger::interface_logFromMultipleStrings( int par)
{
    std::string * s1 = Common::StrManipul::boolToString( true);
    std::string * s2 = Common::StrManipul::doubleToString( +2.7182818E+03 );
    std::string * s3 = Common::StrManipul::longDoubleToString( +3.1415E-03);
    std::string * s4 = Common::StrManipul::uLongLongToString( +123456789);
    std::string * s5 = Common::StrManipul::intToString( -9);
    int hm_strings_toLog = logFromMultipleStrings(
                         5 // hm_params
                         , s1,s2,s3,s4,s5 ); // the actual params
    hm_strings_toLog++;// avoid warn.
}// interface_logFromMultipleStrings


void Test_Unit_Logger::managementMethod()
{
    // the following test logs from ...
    autonomous_logger( -1);// from main thread, without spawning new threads
    singleton_logger( -1);// from main thread, without spawning new threads
    //
    // the following test logs from an automatic(i.e. Stack) instance of Common::SinkFs, forking new threads
    Common::FuncPtr autonomousLogger_funcPtr;
    autonomousLogger_funcPtr = (void (*)(int))(&this->autonomous_logger);// take the address of a member function
    Common::ThreadForker threadForker( autonomousLogger_funcPtr, 8);
    threadForker.theForkingPoint();// forking new threads
    // the following test logs from a Singleton<Common::SinkFs>, forking new threads
    Common::FuncPtr  singletonLogger_funcPtr;
    singletonLogger_funcPtr = (void (*)(int))(&this->singleton_logger);// take the address of a member function
    Common::ThreadForker singleton_threadForker( singletonLogger_funcPtr, 8);
    singleton_threadForker.theForkingPoint();// forking new threads
    // the following test logs from logFromMultipleStrings, forking new threads
    Common::FuncPtr  logFromMultipleStrings_funcPtr;
    logFromMultipleStrings_funcPtr = (void (*)(int))(&this->interface_logFromMultipleStrings);// take the address of a member function
    Common::ThreadForker logFromMultipleStrings_threadForker( logFromMultipleStrings_funcPtr, 98);
    logFromMultipleStrings_threadForker.theForkingPoint();// forking new threads
}// managementMethod


// this method does not log; it's just an example about va_arg
int FindMax (int n, ...)
{
    int i,val,largest;
    va_list vl;
    va_start(vl,n);
    largest=va_arg(vl,int);// the zeroth param is taken here as comparison term.
    for (i=1;i<n;i++)// in this case the comparison needs to be started from one.
    {
        val=va_arg(vl,int);
        largest=(largest>val)?largest:val;
    }
    va_end(vl);
    return largest;
}// this method does not log; it's just an example about va_arg


namespace testLog
{

std::mutex open_phase;
std::mutex trace_phase_1_;
std::mutex trace_phase_2_;
std::mutex trace_phase_3_;
std::mutex close_phase;

void EntryPointThreadSpawn( int par)
{
    open_phase.lock();
    {
        std::stringstream thread_number_open;
        thread_number_open << par;
        //
        std::vector<std::string> opener;
        opener.push_back("EntryPointThreadSpawn");
        opener.push_back(" thread_number= ");
        opener.push_back(thread_number_open.str());
        Process::LogWrappers::SectionOpen_multiMessage( opener, 0);
        opener.clear();
    }
    open_phase.unlock();
    //
    trace_phase_1_.lock();
    {
        std::stringstream thread_number_t1;
        thread_number_t1 << par;
        //
        std::vector<std::string> contentTracer_1;
        contentTracer_1.push_back("Nel mezzo del cammin di nostra vita");
        contentTracer_1.push_back(" thread_number= ");
        contentTracer_1.push_back(thread_number_t1.str());
        Process::LogWrappers::SectionContent_multiMessage( contentTracer_1 , 0);
        contentTracer_1.clear();
    }
    trace_phase_1_.unlock();
    //
    trace_phase_2_.lock();
    {
        std::stringstream thread_number_t2;
        thread_number_t2 << par;
        //
        std::vector<std::string>  contentTracer_2;
        contentTracer_2.push_back("Mi ritrovai per una selva oscura");
        contentTracer_2.push_back(" thread_number= ");
        contentTracer_2.push_back(thread_number_t2.str());
        Process::LogWrappers::SectionContent_multiMessage( contentTracer_2 , 0);
        contentTracer_2.clear();
    }
    trace_phase_2_.unlock();
    //
    trace_phase_3_.lock();
    {
        std::stringstream thread_number__t3;
        thread_number__t3 << par;
        //
        std::vector<std::string>  contentTracer_3;
        contentTracer_3.push_back("che la diritta via era smarrita");
        contentTracer_3.push_back(" thread_number= ");
        contentTracer_3.push_back(thread_number__t3.str());
        Process::LogWrappers::SectionContent_multiMessage( contentTracer_3 , 0);
        contentTracer_3.clear();
    }
    trace_phase_3_.unlock();
    //
    close_phase.lock();
    {
        Process::LogWrappers::SectionClose();
    }
    close_phase.unlock();
    // ready.
}// END EntryPointThreadSpawn


void EntryPointThreadSpawn_TraceOnly_( int par)
{
    //
    trace_phase_1_.lock();
    {
        std::stringstream thread_number_t1;
        thread_number_t1 << par;
        //
        std::vector<std::string> contentTracer_1;
        contentTracer_1.push_back("Nel mezzo del cammin di nostra vita");
        contentTracer_1.push_back(" thread_number= ");
        contentTracer_1.push_back(thread_number_t1.str());
        Process::LogWrappers::SectionContent_multiMessage( contentTracer_1 , 0);
        contentTracer_1.clear();
    }
    trace_phase_1_.unlock();
    //
    trace_phase_2_.lock();
    {
        std::stringstream thread_number_t2;
        thread_number_t2 << par;
        //
        std::vector<std::string>  contentTracer_2;
        contentTracer_2.push_back("Mi ritrovai per una selva oscura");
        contentTracer_2.push_back(" thread_number= ");
        contentTracer_2.push_back(thread_number_t2.str());
        Process::LogWrappers::SectionContent_multiMessage( contentTracer_2 , 0);
        contentTracer_2.clear();
    }
    trace_phase_2_.unlock();
    //
    trace_phase_3_.lock();
    {
        std::stringstream thread_number__t3;
        thread_number__t3 << par;
        //
        std::vector<std::string>  contentTracer_3;
        contentTracer_3.push_back("che la diritta via era smarrita");
        contentTracer_3.push_back(" thread_number= ");
        contentTracer_3.push_back(thread_number__t3.str());
        Process::LogWrappers::SectionContent_multiMessage( contentTracer_3 , 0);
        contentTracer_3.clear();
    }
    trace_phase_3_.unlock();
    // ready.
}// END EntryPointThreadSpawn_TraceOnly_


bool configFileTestGenerator()
{
    std::fstream theOutStream;
    std::string configFpath("./AppConfig.txt");
    bool opened = true;// TODO
    Common::Stream::outstreamOpener( configFpath, theOutStream); //  TODO undefined reference
    const int threshold = 125;// has to be odd(dispari).
    const int n_couples_keyVal =(int)(threshold/2);
    for(int c=0; c<threshold; c++)
    {// putline ( const std::string &theLine,  std::fstream &theOutStream )
        if(n_couples_keyVal>c)
        {
            std::stringstream tmp;
            tmp << "key_" << c+1;
            Common::Stream::putline( tmp.str(), theOutStream);
        }
        else if(n_couples_keyVal==c)
        {
            std::stringstream tmp;
            tmp << "#";
            Common::Stream::putline( tmp.str(), theOutStream);
        }
        else // if(n_couples_keyVal<c)
        {
            std::stringstream tmp;
            tmp << "val_" << c-n_couples_keyVal;
            Common::Stream::putline( tmp.str(), theOutStream);
        }// end putline
    }// end for
    opened &= Common::Stream::outstreamCloser(theOutStream);
    return opened;
}// END configFileTestGenerator



int recursionLevel=0;

void logTest_monothread_()
{
    Process::LogWrappers::SectionOpen("void logTest_1()", 0);
    //
    while(25>recursionLevel)
    {
        ++recursionLevel;
        std::stringstream sStream;
        sStream << recursionLevel;
        std::string LogText("this is some content, logged from inside the current function. Recursion== " + sStream.str() );
        Process::LogWrappers::SectionContent( LogText.c_str(), 0);
        logTest_monothread_();
    }
    //
    Process::LogWrappers::SectionClose();
}


}// end nmsp testLog

