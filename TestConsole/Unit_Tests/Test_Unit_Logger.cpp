#include <stdarg.h>     /* va_list, va_start, va_arg, va_end */
#include "Test_Unit_Logger.h"

Test_Unit_Logger::Test_Unit_Logger()
{
    //ctor
}

Test_Unit_Logger::~Test_Unit_Logger()
{
    //dtor
}


void Test_Unit_Logger::autonomous_logger(int threadNum)
{// a negative threadNum param means the call has been spawn from the main thread.
    Common::SinkFs log;
    //
    log.SectionOpen("autonomous_logger", 0);
    for(int c=0; c<10; c++)
    {
        std::string threadLabel("from inside autonomous_logger:: thread number ");
        std::string * converter = Common::StrManipul::intToString( threadNum);
        threadLabel += *converter;
        delete converter;
        log.SectionTrace( threadLabel, 0);
    }
    log.SectionClose();
}// autonomous_logger


void Test_Unit_Logger::singleton_logger(int threadNum)
{// a negative threadNum param means the call has been spawn from the main thread.
    // no log instance -> Singleton
    Process::LogWrappers::SectionOpen("singleton_logger", 0);
    for(int c=0; c<10; c++)
    {
        std::string threadLabel("from inside singleton_logger:: thread number ");
        std::string * converter = Common::StrManipul::intToString( threadNum);
        threadLabel += *converter;
        delete converter;
        Process::LogWrappers::SectionContent( threadLabel.c_str() , 0);
    }
    Process::LogWrappers::SectionClose();
}// singleton_logger



// TODO goes in Process::Log_Wrappers
// TODO let the prototype take std::string* and delete --------------------(V)
// TODO let the prototype use a StringBuilder to concatenate the input ----(V)
int Test_Unit_Logger::logFromMultipleStrings(int howMany_params, ...)
{// takes an unspecified number of std::string and concatenates them, with  blank in between.
    Process::LogWrappers::SectionOpen("logFromMultipleStrings", 0);
    int loopCounter;
    std::string * val;// the choosen data-type; string* generated by conversion of vars to be logged.
    va_list v_list;// va_list is the data-type of the unspecified parameters
    va_start( v_list, howMany_params);// va_start is the macro to open the set.
    Common::StringBuilder sb( 100 * howMany_params);// estimate 100 chars per param; auto.
    sb.append( std::string("composition state : "));
    for( loopCounter=0; loopCounter<howMany_params; loopCounter++)
    {// the macro va_arg can be queried from zero to  to need to howMany_params-1.
        val = va_arg( v_list, std::string* );// get the current one of the params
        sb.append( *val);// use the StringBuilder to append
        sb.append( std::string("  "));
        delete val;// delete the original. TODO test
    }
    va_end( v_list);// macro to close the set.
    //
    Process::LogWrappers::SectionContent( sb.str().c_str() , 0);
    //std::cout<< "\n\t composition state : "<< sb.str(); // DBG
    Process::LogWrappers::SectionClose();
    // ready.
    return howMany_params;// return how many params have been given
}// logFromMultipleStrings


void Test_Unit_Logger::interface_logFromMultipleStrings( int par)
{
    std::string * s1 = Common::StrManipul::boolToString( true);
    std::string * s2 = Common::StrManipul::doubleToString( +2.7182818E+03 );
    std::string * s3 = Common::StrManipul::longDoubleToString( +3.1415E-03);
    std::string * s4 = Common::StrManipul::uLongLongToString( +123456789);
    std::string * s5 = Common::StrManipul::intToString( -9);
    int hm_strings_toLog = logFromMultipleStrings(
                         5 // hm_params
                         , s1,s2,s3,s4,s5 ); // the actual params
    hm_strings_toLog++;// avoid warn.
}// interface_logFromMultipleStrings


void Test_Unit_Logger::managementMethod()
{
    // the following test logs from ...
    autonomous_logger( -1);// from main thread, without spawning new threads
    singleton_logger( -1);// from main thread, without spawning new threads
    //
    // the following test logs from an automatic(i.e. Stack) instance of Common::SinkFs, forking new threads
    Common::FuncPtr autonomousLogger_funcPtr;
    autonomousLogger_funcPtr = (void (*)(int))(&this->autonomous_logger);// take the address of a member function
    Common::ThreadForker threadForker( autonomousLogger_funcPtr, 8);
    threadForker.theForkingPoint();// forking new threads
    // the following test logs from a Singleton<Common::SinkFs>, forking new threads
    Common::FuncPtr  singletonLogger_funcPtr;
    singletonLogger_funcPtr = (void (*)(int))(&this->singleton_logger);// take the address of a member function
    Common::ThreadForker singleton_threadForker( singletonLogger_funcPtr, 8);
    singleton_threadForker.theForkingPoint();// forking new threads
    // the following test logs from logFromMultipleStrings, forking new threads
    Common::FuncPtr  logFromMultipleStrings_funcPtr;
    logFromMultipleStrings_funcPtr = (void (*)(int))(&this->interface_logFromMultipleStrings);// take the address of a member function
    Common::ThreadForker logFromMultipleStrings_threadForker( logFromMultipleStrings_funcPtr, 98);
    logFromMultipleStrings_threadForker.theForkingPoint();// forking new threads
}// managementMethod


// this method does not log; it's just an example about va_arg
int FindMax (int n, ...)
{
    int i,val,largest;
    va_list vl;
    va_start(vl,n);
    largest=va_arg(vl,int);// the zeroth param is taken here as comparison term.
    for (i=1;i<n;i++)// in this case the comparison needs to be started from one.
    {
        val=va_arg(vl,int);
        largest=(largest>val)?largest:val;
    }
    va_end(vl);
    return largest;
}// this method does not log; it's just an example about va_arg
