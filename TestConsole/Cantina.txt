
/***********************************************  cantina *****************************************************


void tryReadBackwards()// platform dependent.
{// NB. works on Linux but not on Windows.
    std::ifstream in;
    in.open("nelMezzo.txt");
    char ch;
    int pos;
    in.seekg(-1,ios::end);
    pos=in.tellg();
    for(int i=0;i<pos;i++)
    {
        ch=in.get();
        cout<<ch;
        in.seekg(-2,ios::cur);
    }
    in.close();
}//tryReadBackwards

void tryReadForewards()
{
    std::ifstream in;
    in.open("nelMezzo.txt");
    char ch;
    int pos;
    in.seekg(-1,ios::end);
    pos=in.tellg();
    in.seekg(0,ios::beg );// go back to the starting point.
    for(int i=0;i<pos;i++)
    {
        ch=in.get();
        cout<<ch;
        // NB. no seek reading forewards; it's implicitly in.seekg(+1,ios::cur);
    }
    in.close();
}//tryReadBackwards


    int bisectionConvergenceSteps = p->Bisection( 73, 100, false);
    for(int c=1; c<=100;c++)// NB. you cannot require an ordinal<+1.
    {
        std::cout << "\n\t converging in " << p->Bisection( c, 100, false) <<" steps."<<std::endl;
    }
    //int NsectionConvergenceSteps = p->NpartSection( 73, 100, false);
    for(int c=73; c<=100;c++)
    {
        std::cout<<" steps for Bisection to converge to LandingPoint_"<<c<<" are:"<< p->Bisection( c, 100, false)<<std::endl;
        std::cout<<" steps for NpartSection to converge to LandingPoint_"<<c<<" are:"<< p->NpartSection( c, 100, false)<<std::endl;
    }

//    as is
//    "testCowsCanBeMilked"
//    "testSheepAreNotTheOnlyFruit"
//    // to be
//    "Cows can be milked"
//    "Sheep are not the only fruit"
//

    std::vector<std::string> * camelToken = nullptr;// many usages: allocated & deleted each time.
    //
    std::string * original_one = new std::string("testCowsCanBeMilked");
    testCallerQuestTwo( original_one);

    std::string * original_two = new std::string("testSheepAreNotTheOnlyFruit");
    testCallerQuestTwo( original_two);

    std::string * original_three = new std::string("testSheep WrittenNot123#So23@Good really");
    testCallerQuestTwo( original_two);


char toLower(const char par)
{
    if( (int)par>=65 && (int)par<=90)
    {
        return ( (char)((int)(par)+32));
    }
    else
    {
        return par;// if it's not an upper case letter, don't convert it.
    }
}

bool isUpper(const char par)
{
    bool res = false;
    if( (int)par>=65 && (int)par<=90)
    {
        res = true;
    }// else stay false.
    //    if( (int)par>=97 && (int)par<=122)
    //    {
    //        res = false;
    //    } this is should be for lower case
    // done
    return res;
}



// as is
//"testCowsCanBeMilked"
//"testSheepAreNotTheOnlyFruit"
//// to be
//"Cows can be milked"
//"Sheep are not the only fruit"
//
std::vector<std::string> * camelTokenizer( const std::string * original_one )
{
    std::vector<std::string> * camelToken = new std::vector<std::string>();
    Common::StringBuilder * curToken = new Common::StringBuilder( original_one->length());// round in excess
    // if(curChar is NOT upper -> pushBack)
    // else if(curChar is upper -> terminateCurStrBuilder -> Start a new one with toLower(curChar) )
    //
    int c=0;//needed after endOfLoop
    for( ; c<original_one->length(); c++)
    {
        if( ! isUpper( original_one->at(c) ) )
        {
            curToken->append( original_one->at(c) );
        }
        else // not upper
        {
            camelToken->push_back( curToken->str() );
//std::cout<< curToken->str() <<std::endl;
            delete curToken;
            curToken = nullptr;
            curToken = new Common::StringBuilder( original_one->length());// get ready for another one
            curToken->append( toLower( original_one->at(c) ) );
        }// end else  not upper
    }// end for
    //---recover last token, which has no capitalLetter to signal its registration
    camelToken->push_back( curToken->str() );
//std::cout<< curToken->str() <<std::endl;
    delete curToken;
    curToken = nullptr;
    // no successive token, to get ready for.
    return camelToken;
}// end camelTokenizer(


void testCallerQuestTwo( const std::string * original_one )
{
    std::vector<std::string> * camelToken = camelTokenizer( original_one);
    // rewind
    for( std::vector<std::string>::iterator theTokens=camelToken->begin();
        theTokens != camelToken->end();
        theTokens++
    )
    {
        std::cout << *theTokens << " ";
    }
    std::cout << std::endl;
    delete original_one;
    delete camelToken;
}// end testCallerQuestTwo(



/// l'integrando (-z)^s/(Exp[z]-1)dz/z
Numerics::Complex * IcoChain( Numerics::Complex s, Numerics::Complex z)
{
    Numerics::Complex numerator(-z);
    numerator ^=s;
    Numerics::Complex denominator((z.ExpC()-1.0)*z);
    Numerics::Complex * res = new Numerics::Complex( numerator / denominator);//---caller has to delete----------
    return res;
}// IcoChain


Numerics::Complex * pointFromOriginAnulus( double delta, double Theta )
{// this parametrization is: (delta*Cos[t] + I*delta*Sin[t])
    // take the desired point, on the unit ball: i.e. the versor.
    Numerics::Complex * res = new Numerics::Complex( cos(Theta) , sin(Theta) );//NB. caller has to delete.
    *res *= delta;// then take it on the appropriate ball, by omothetia.
    return res;
}// pointFromOriginAnulus


Numerics::Complex * originAnulus( double stepSize, int stepOrdinal, double delta)
{// this parametrization is: (delta*Cos[t] + I*delta*Sin[t])
    Domain domain;//to be thrown
    int stepCardinality = +2.0*PI/stepSize;
    if(stepOrdinal>stepCardinality){throw domain;}
    double Theta = +2.0*PI*(double)stepOrdinal/(double)stepCardinality;
    Numerics::Complex * res = new Numerics::Complex( cos(Theta) , sin(Theta) );//NB. caller has to delete.
    *res *= delta;
    return res;
}// originAnulus


// NB. cannot step for numerical integration in Complex plane like this: the real and immaginary parts of the image( i.e. u(x,y) and v(x,y) ) have
// to be separated, to step.
Numerics::Complex * integralStepIntoOriginAnulus( double stepSize, double radius, Numerics::Complex s)
{// this parametrization is: (radius*Cos[t] + I*radius*Sin[t])
    Numerics::Complex * accumulator = new Numerics::Complex( 0.0 , 0.0);
    int stepCardinality = +2.0*PI/stepSize;
    double Theta =0.0;
    for(int curStep=0; curStep<stepCardinality; curStep++)
    {
        Theta = +2.0*PI*(double)curStep/(double)stepCardinality;
        Numerics::Complex * pointOnCircularChain = pointFromOriginAnulus( radius, Theta );
        Numerics::Complex * pointOn_COchain = IcoChain( s, *pointOnCircularChain);
        *accumulator += *pointOn_COchain;
        delete pointOnCircularChain;
        delete pointOn_COchain;
    }
    return accumulator;// caller has to delete.
}// originAnulus


Numerics::Complex * imageStepIntoOriginAnulus( double stepSize, double radius, Numerics::Complex s, int curStep)
{// this parametrization is: (radius*Cos[t] + I*radius*Sin[t])
    int stepCardinality = +2.0*PI/stepSize;
    double Theta =0.0;
    Theta = +2.0*PI*(double)curStep/(double)stepCardinality;
    Numerics::Complex * pointOnCircularChain = pointFromOriginAnulus( radius, Theta );
    Numerics::Complex * pointOn_COchain = IcoChain( s, *pointOnCircularChain);
    delete pointOnCircularChain;
    //
    return pointOn_COchain;// caller has to delete.
}// originAnulus

Numerics::Complex * imageStepIntoLinearHankelBranch( Numerics::Complex s, Numerics::Complex z)
{// this parametrization is: z=:(t  + I*epsilon). It is used both to go from +Infinity to the origin and back.
    Numerics::Complex * pointOn_COchain = IcoChain( s, z);
    return pointOn_COchain;// caller has to delete.
}// originAnulus


//    PrimesFinder::Primes p(100);
//    bool CtorStatus = p.isHealthlyConstructed;
//    int64_t aPrime = p[20];

//    Numerics::Complex s(+0.35, +20.15);
//    const double epsilon = -9.0;// a macro distance
//    const double step = +1.0;// a macro step
//    Numerics::Complex z( fabs(epsilon), epsilon);
//    int stepCardinality = 10;
//    //
//    //--dump on txtFile ----------------------------
//	std::string thePath("./out20220219_.txt");// TODO read with Java and push to PostgreSql.
//	std::fstream theStream;
//	bool result = Common::Stream::outstreamOpener( thePath , theStream );
//    std::string * curField = nullptr;
//
//
//    // calculate each image point via the coChain (-x)^s/(x*(Exp[x]-1))dx (x is a Complex variable here).
//    Numerics::Complex * imagePoint = nullptr;
//    for(int curStep=0; curStep<stepCardinality; curStep++)
//    {
//        Common::StringBuilder sb(90);// the stringBuilder needs to be reset at every loop-step.
//        imagePoint = imageStepIntoLinearHankelBranch( s, z);//-----calculation------the imagePoint gets allocated inside the calculation and gets freed at each for-step.
//        //-----prepare the StringBuilder for a single line------
//        //------------------------------- s ----------------------------------------------------
//        curField = Common::StrManipul::doubleToString( s.Re() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( s.Im() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        //------------------------------- z ----------------------------------------------------
//        curField = Common::StrManipul::doubleToString( z.Re() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( z.Im() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        //------------------------------- image ----------------------------------------------------
//        curField = Common::StrManipul::doubleToString( imagePoint->Re() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( imagePoint->Im() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //----------------------------------------this last parameter end the line, in the txtDump.----------------------------
//        //--------update params-------------------------------
//        z += Numerics::Complex( step, 0);// Hankel linear branches require to stay parallel to the abscissa.
//        //
//        //-----finally dump the line
//        Common::Stream::putline( sb.str() , theStream);//---this appends a \n
//        delete imagePoint;
//    }
//    result = Common::Stream::outstreamCloser( theStream );// only after the complete loop, close the dumpStream.
    double radius = +3.7123E+01;
    double stepSize = +2.0*PI/900.0;
=======

int main()
{
//    Numerics::Complex z(+3.1 , 5.2);
//    for( int n=0; n<6; n++)
//    {
////        Numerics::Complex  curExponent((double)n, 0.0);
////        Numerics::Complex res = z^curExponent;
//        Numerics::Complex res = z^n;
//        std::cout<<"\n\t("<<z.Re()<<"+I*"<<z.Im()<<")^"<<n<<" == "<< res.Re()<<"+I*"<<res.Im();
//    }
////
////For[
//// t = 1; base = +2.1*t + I*3.1*t; espon = +2.3*t + I*1.6*t;,
//// t < 6,
//// Print["t==", t, " base^espon==" , base, "^", espon, " == ",
////  base^espon  ];
//// t += +0.4;
//// base = +2.1*t + I*3.1*t;
//// espon = +2.3*t + I*1.6*t;
//// ]
//for( double t=+1.0; t<+6.0; t+=+0.4 )
//{
//    Numerics::Complex base ( +2.1*t , 3.1*t );
//    Numerics::Complex espon( +2.3*t , 1.6*t );
//    Numerics::Complex res = base^espon;
//    std::cout<<"\n\t("<<base.Re()<<"+I*"<<base.Im()<<")^"<<
//                   "("<<espon.Re()<<"+I*"<<espon.Im()<<") == "<< res.Re()<<"+I*"<<res.Im();
//}

//for( double t=+91.0; t<+116.0; t+=+0.4 )
//{
//    Numerics::Complex espon( +2.3*t , 1.6*t );
//    Numerics::Complex res = espon.ExpC();
//    Numerics::Complex res_selfish = espon.ExpC_selfish();
//    std::cout<<"\n\t Exp["<<espon.Re()<<"+I*"<<espon.Im()<<"] == "<< res.Re()<<"+I*"<<res.Im()<<
//    "  selfish: "<< res_selfish.Re()<<"+I*"<<res_selfish.Im();
//}

	std::string thePath("./out20220219_.txt");
	std::fstream theStream;
	//
	bool result = Common::Stream::outstreamOpener( thePath , theStream );
    double radius = +3.7123E+01;
    double stepSize = +2.0*PI/900.0;
    Numerics::Complex s(+0.35, +20.15);
    Numerics::Complex * integralOnOriginAnulus = integralStepIntoOriginAnulus( stepSize, radius, s);
    std::string * curField = nullptr;
    Common::StringBuilder sb(90);
    //
    curField = Common::StrManipul::doubleToString( integralOnOriginAnulus->Re() );
    sb.append( *curField );
    sb.append((int)'\t');
    delete curField;
    //
    curField = Common::StrManipul::doubleToString( integralOnOriginAnulus->Im() );
    sb.append( *curField );
    sb.append((int)'\t');
    delete curField;
    //
    //-----finally dump the line
    Common::Stream::putline( sb.str() , theStream);
    result = Common::Stream::outstreamCloser( theStream );
    delete integralOnOriginAnulus;


//    for(int c=0; c<100; c++)
//    {
//        Numerics::Complex * res = originAnulus( stepSize, c, delta );
//        std::cout<<"originAnulus(stepSize,c,delta)=="<<stepSize<<c<<delta<<" == "<< res->Re()<<" +I* "<< res->Im()<<" length=="<< res->length() <<std::endl;
//        Common::StringBuilder sb(90);
//        std::string * curField = nullptr;
//        //
//        curField = Common::StrManipul::doubleToString( stepSize);
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::intToString( c);
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( delta);
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( res->Re());
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( res->Im());
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( res->length());
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //-----finally dump the line
//        Common::Stream::putline( sb.str() , theStream);
//        delete res;
//    }
//	result = Common::Stream::outstreamCloser( theStream );

//    Numerics::Complex s(+0.5 , +13.7);
//    Numerics::Complex *z = new Numerics::Complex(1, 3);
//    Numerics::Complex icoChain( IcoChain( s, *z) );
//    delete z;

    //
    std::cout<<"\n\n\n\t Strike Enter to leave\t";
    getchar();
    return 0;
}// main



/* --------------cantina----------------------------

    //PrimesFinder::Primes * p = new PrimesFinder::Primes(100);
//    long desPrime = (*p)[p->lastOrdinal];
//    int bisectionConvergenceSteps = p->Bisection( 73, 100, false);
////for(int c=0; c<=100;c++)
////    {
////        std::cout << "\n\t converging in " << p->Bisection( c, 100, false) <<" steps."<<std::endl;
////    }
//    //int NsectionConvergenceSteps = p->NpartSection( 73, 100, false);
//    for(int c=73; c<=100;c++)
//    {
//        std::cout<<" steps for Bisection to converge to LandingPoint_"<<c<<" are:"<< p->Bisection( c, 100, false)<<std::endl;
//        std::cout<<" steps for NpartSection to converge to LandingPoint_"<<c<<" are:"<< p->NpartSection( c, 100, false)<<std::endl;
//    }
    //delete p;


//    p = new PrimesFinder::Primes(5000000); // re-use
//    p->Start_PrimeDump_FileSys();
//    lastOrdinal = p->getLastOrdinal();
//    lastPrime = p->getLastPrime();
//    presentLength = p->getActualLength();
//
//     unsigned long res = (*p)[25];// TODO bug [lastOrdinal] #######################################################
//     res = (*p)[1];
//     res = (*p)[2];
//     res = (*p)[3];
//     res = (*p)[lastOrdinal];
//     res = (*p)[lastOrdinal-1];
//     res = (*p)[lastOrdinal-2];
//     res = (*p)[lastOrdinal-3];
//     res = (*p)[lastOrdinal-100];
//     if(overflowFlag==res)
//     {
//         std::cout<<"\n\t invalid index fed to operator[] "<<std::endl;
//     }
//     for( int c=1; c<=15; c++)
//     {
//         std::cout<<"\n\t Prime["<<c<<"]=="<<(*p)[c];
//     }
//     for( int c=lastOrdinal-500; c<=lastOrdinal-50; c++)
//     {
//         std::cout<<"\n\t Prime["<<c<<"]=="<<(*p)[c];
//     }
//     const char * theDumpPath = p->getPrimeDumpFullPath( "primeDefaultFile");// Default Section Name.
//     if( nullptr != theDumpPath)
//      {}// else : TODO not-healthly built.
//     const char * straightContentOfDumpTail  = p->dumpTailReader( theDumpPath);
////PrimesFinder::Primes::DumpElement * dumpTail = p->recoverDumpTail( straightContentOfDumpTail);
//     PrimesFinder::Primes::SingleFactor * factorization = p->IntegerDecomposition( (*p)[30123]*7);

////
////     delete[] theDumpPath;
////     delete[] straightContentOfDumpTail;
//     delete[] factorization;
//    //delete[] dumpTail;
//     delete p;

 // MonteCarlo
    double left  = -92.809;
    double right = +12.209;

    int populationCardinality = 9000;
    //
    Common::MonteCarlo::ClassicalDiscreteGenerator * monteCGen =
    new Common::MonteCarlo::ClassicalDiscreteGenerator();// Ctor
    monteCGen->resetExtractionInterval( left, right);// NB. compulsory
    for( int c=0; c<populationCardinality;c++)
    {
        monteCGen->nextIntegerInInterval();
    }
    //monteCGen->showDiscretePopulation();
    monteCGen->buildOmega( left, right );
    monteCGen->buildDiscreteFrequencyDistribution();
    std::cout<<"\n\n\t -------- START discrete model;"<<std::endl;
    monteCGen->showFrequencyDistribution();
    monteCGen->showCumulatedFrequency();
    delete monteCGen;

    std::cout<<"\n\t -------- END discrete model; START continuous model \n"<<std::endl;

    Common::MonteCarlo::ClassicalContinuousGenerator * monteCGen_D =
    new Common::MonteCarlo::ClassicalContinuousGenerator();// Ctor
    monteCGen_D->resetExtractionInterval( left, right);// NB. compulsory
    for( int c=0; c<populationCardinality;c++)
    {
        monteCGen_D->nextDoubleInInterval();
    }
    //monteCGen_D->showContinuousPopulation();
    monteCGen_D->buildOmega( left, right );
    monteCGen_D->buildContinuousFrequencyDistribution();
    monteCGen_D->showFrequencyDistribution();
    monteCGen_D->showCumulatedFrequency();

    delete monteCGen_D;
 // MonteCarlo


  std::string s("Nel mezzo#@# del cammin#@# di nostra vita,#@# mi ritrovai#@#  #@# #@# #@# per una selva oscura#@#.");
  std::vector<std::string> * tokens = Common::StrManipul::stringSplit("#@#", s, false);
  std::vector<std::string> * cleanTokens = Common::StrManipul::removeEmptyEntries( tokens);

  if( NULL != tokens)
  {
  for( std::vector<std::string>::const_iterator readerTk = tokens->begin();
        readerTk != tokens->end();
        readerTk++
     )
    {
        std::cout<< *readerTk<<std::endl;
    }
  }// else skip on NULL.
  //
  if( NULL != cleanTokens)
  {
  for( std::vector<std::string>::const_iterator readerCleanTk = cleanTokens->begin();
        readerCleanTk != cleanTokens->end();
        readerCleanTk++
     )
    {
        std::cout<< *readerCleanTk<<std::endl;
    }
  }// else skip on NULL.
  //
  delete tokens;
  delete cleanTokens;


    Common::MonteCarlo::BaseConverter b(false);
    const unsigned long threshold = +1.5E6;

    for(unsigned long c=0; c<threshold; c++)
    {
        for( int base=2; base<=64; base++)
        {
            std::string * converted = b.baseOtherConverterTo( c, base);
            unsigned long reConverted = b.base10ConverterTo( *converted, base);
            if( reConverted != c)
            {
                std::cout<<"\n\t Allarme ! c:"<<c<<" base:"<<base<<std::endl;
            }
            else
            {
//                std::cout<<"\n\t OK ! converted: "<<*converted
//                <<" reConverted:"<<reConverted
//                <<" original:"<<c
//                <<" base:"<<base<<std::endl;
            }
            delete converted;
        }
    }

void boost_test()
{
    using namespace boost::lambda;
    typedef std::istream_iterator<int> in;

    std::for_each(
                    in(std::cin)
                    , in()
                    , std::cout << (_1 * 3) << " "
                  );
}// end boost_test



double f(double x)
{
    //return exp(x)*cos(x);
    return x*x;
}


//
//    std::string * charToString( const char par)
//    {
//        std::string * res = new std::string();
//        std::stringstream localSstream;
//        localSstream << par;//put the char into the stringStream
//        *res = localSstream.str();// get the string from the stringStream
//        // N.B. the caller has to delete the return value.
//        return res;
//    }
//


//typedef struct _GUID {
//    unsigned long  Data1;
//    unsigned short Data2;
//    unsigned short Data3;
//    unsigned char  Data4[8];
//} GUID;
//std::string * getGUID( int randInitializer)
//{
//    Common::MonteCarlo * mCarlo = new Common::MonteCarlo( randInitializer);// user suggested seed.
//    Common::StringBuilder * sb = new Common::StringBuilder(17) ;
//    for( int c=0; c<16; c++)
//    {
//        int tmp = -1;
//        while( 33>tmp || 126<tmp)
//        {
//            tmp = mCarlo->nextProbabilityMeasure() * 127;// selected code
//        }
//        sb->append( tmp);
//    }
//    delete mCarlo;
//    std::string * res = new std::string( sb->str() );// caller has to delete.
//    delete sb;
//    return res;
//}// getGUID()





namespace Common{
namespace MonteCarloNamespace{
namespace Development{

// DeltaOmega is the DeltaAscissa in a Riemann partition of the Omega Event-space.
class DeltaOmega
{// an instance of DeltaOmega is a single step in the Riemann partition. The friend function "buildOmega" builds a vector, which contains the whole population of
 // DeltaOmega, which constitutes the whole Omega event space.
private:
    friend class MonteCarloGenerator;
    double mediana;
    double eta;
    double categoryFrequency;
public:
    DeltaOmega( double medianaPoint, double etaMeasure)
    {
        this->mediana = medianaPoint;
        this->eta = etaMeasure;
        this->categoryFrequency = 0.0;// init and then add on.
    }// Ctor
    double getMediana(){return this->mediana;}
    bool belongsToDeltaOmega( double candidate)
    {
        bool res = fabs( candidate-this->mediana)<this->eta;
        return res;
    }
};// class DeltaOmega


    class MonteCarloGenerator
    {
    private:
        friend class DeltaOmega;
        bool ConstructorCanContinue;
        std::string * ReasonForAbortingConstructor;
        double theIntervalMeasure;
        double Min, Sup;
        double omothetia;
        bool leftClosed, rightClosed;
        std::vector<double> * population;
        std::vector<DeltaOmega> * frequencyDistribution;

    public:
     MonteCarloGenerator( double left, bool isLeftIncluded
                         ,double right, bool isRightIncluded
                         ,bool wantContinuousModel ):ConstructorCanContinue(true)
                         ,ReasonForAbortingConstructor(new std::string("NOT YET.") )
                         ,theIntervalMeasure(right-left)
                         ,Min(left), Sup(right)
                         ,leftClosed( isLeftIncluded), rightClosed( isRightIncluded)
                         ,population( new std::vector<double>() )
                         ,frequencyDistribution(  new std::vector<DeltaOmega>() )
         {
             //theIntervalMeasure = right-left;// init for both models; correct only for discrete ones.
             // default model is [min,sup) on [0,RAND_MAX)==[0,32767)
             if( ! wantContinuousModel)//---------------------- discrete -------------------------------------------------
             {
                 if( fabs(left-(int)left)>+1E-80
                     || fabs(right-(int)right)>+1E-80 )
                 {
                     ConstructorCanContinue = false;
                     delete this->ReasonForAbortingConstructor;//free memory of default Ctor message.
                     this->ReasonForAbortingConstructor = new std::string("Invocation of a discrete model, with non Diophantine boundaries. Aborting.");
                 }
                 else // estremi interi
                 {// non default boundary conditions.
                     if( !isLeftIncluded)
                     {
                         left += +1.0;
                         theIntervalMeasure -= +1.0;// NB. such corrections only affect the discrete case, since they have zero measure on continuous models.
                     }// else the default is already appropriate
                     if( isRightIncluded)
                     {
                         right += +1.0;
                         theIntervalMeasure += +1.0;
                     }// else the default is already appropriate
                 }// estremi interi
             }////-------END--------------- discrete -------------------------------------------------
             this->omothetia = this->theIntervalMeasure/((double)RAND_MAX);
             //
         }// Ctor

        void nextIntegerInInterval() const
        {
            double temp =  rand()*this->omothetia+this->Min;
            this->population->push_back( (int)temp);
        }// END nextIntegerInInterval

        void nextDoubleInInterval() const
        {
            double temp = rand()*this->omothetia+this->Min;
            if( this->rightClosed)
            {
                while( temp>this->Sup)
                {
                    temp = rand()*this->omothetia+this->Min;
                }
            }
            this->population->push_back( temp);
        }// END nextIntegerInInterval

        void showPopulation() const
        {
            for( std::vector<double>::const_iterator it=this->population->begin();
                 it!=this->population->end();
                 it++
                )
                {
                    std::cout<< *it<<std::endl;
                }
        }// END showPopulation() const

        void showFrequencyDistribution() const
        {
            for( std::vector<DeltaOmega>::const_iterator it=this->frequencyDistribution->begin();
                 it!=this->frequencyDistribution->end();
                 it++
                )
                {

                        double mediana;
                        double eta;
                        double categoryFrequency;

                    std::cout<<" mediana "<< *Common::StrManipul::doubleToString(it->mediana)<<" eta "
                    << *Common::StrManipul::doubleToString(it->eta)
                    <<" categoryFrequency "<<*Common::StrManipul::doubleToString(it->categoryFrequency) <<std::endl;
                }
        }// END showFrequencyDistribution() const

        void showCumulatedFrequency() const
        {
           double CumulatedFrequency = 0.0;
           for( std::vector<DeltaOmega>::iterator frequencyWriter=this->frequencyDistribution->begin();
                frequencyWriter != this->frequencyDistribution->end();
                frequencyWriter++
              )
              {
                 CumulatedFrequency += frequencyWriter->categoryFrequency;
              }// for frequencyWriter
              std::cout<< "\n\n\t CumulatedFrequency : " << CumulatedFrequency <<std::endl;
        }// END showCumulatedFrequency() const


        void buildFrequencyDistribution()
        {
            int populationCardinality = this->population->size();
            double elementPresenceWeight = +1.0/populationCardinality;
            for( std::vector<double>::const_iterator populationReader=this->population->begin();
                 populationReader != this->population->end();
                 populationReader++
               )
               {
                   for( std::vector<DeltaOmega>::iterator frequencyWriter=this->frequencyDistribution->begin();
                        frequencyWriter != this->frequencyDistribution->end();
                        frequencyWriter++
                      )
                      {
                          if( frequencyWriter->belongsToDeltaOmega( *populationReader) )
                          {
                              frequencyWriter->categoryFrequency += elementPresenceWeight;
                              break;// belonging class found.
                          }
                      }// for frequencyWriter

               }// for populationReader
        }// buildFrequencyDistribution()



        void buildOmega( double partizioneLeft
                         ,double partizioneRight
                         ,double eta
                       )
        {//this->frequencyDistribution has been built by Ctor.
            for( double position=partizioneLeft-eta; position<=partizioneRight+eta; position+=2*eta)
            {
                DeltaOmega * curDeltaOmega = new DeltaOmega( position+eta, eta);// TODO verify
                this->frequencyDistribution->push_back( *curDeltaOmega );
            }//for
        }//buildOmega



    };// class MonteCarloGenerator


std::string * exadecimalConverterTo( unsigned int par )
{
    const std::string exaFigures("0123456789ABCDEF");
    Common::StringBuilder sb(20);
    sb.append("0x");//start with Hex prefix.
    int abacusLeftMostPosition = log(par)/log(16);
    double dividendo = (double)par;
    for( ;abacusLeftMostPosition>=0; abacusLeftMostPosition--)
    {
        double quotient = dividendo/ pow(+16.0,(double)abacusLeftMostPosition);
        double resto = dividendo - ((int)quotient)*pow(+16.0,(double)abacusLeftMostPosition);
        // update
        sb.append( exaFigures[(int)quotient]);
        dividendo = resto;
    }
    //ready.
    std::string * res = new std::string( sb.str());
    return res;// caller has to delete.
}

std::string * base64ConverterTo( unsigned int par )
{

        [48,57]
        [65,90]
        [97,126]

    Common::StringBuilder sbB4symbols( 66);
    for( int c=48;c<=57;c++)// figures
    {//NB. append(int) appende alla stringa il simbolo corrispondente al codice int.
        sbB4symbols.append(c);
    }
    for( int c=65;c<=90;c++)
    {// upper case letters
        sbB4symbols.append(c);
    }
    for( int c=97;c<=126;c++)
    {// lower case letters + some symbols
        sbB4symbols.append(c);
    }

    std::string base64Figures( sbB4symbols.str() );
    std::cout<< base64Figures<<std::endl;



    Common::StringBuilder sb( 100);
    sb.append("b64_");//start with base64 prefix.
    int abacusLeftMostPosition = log(par)/log(64);
    double dividendo = (double)par;
    for( ;abacusLeftMostPosition>=0; abacusLeftMostPosition--)
    {
        double quotient = dividendo/ pow(+64.0,(double)abacusLeftMostPosition);
        double resto = dividendo - ((int)quotient)*pow(+64.0,(double)abacusLeftMostPosition);
        // update
        sb.append( base64Figures[(int)quotient]);
        dividendo = resto;
    }
    //ready.
    std::string * res = new std::string( sb.str());
    return res;// caller has to delete.
}

unsigned long base10ConverterTo( const std::string & base64par )
{

        [48,57]
        [65,90]
        [97,126]

    Common::StringBuilder sbB4symbols( 66);
    for( int c=48;c<=57;c++)// figures
    {//NB. append(int) appende alla stringa il simbolo corrispondente al codice int.
        sbB4symbols.append(c);
    }
    for( int c=65;c<=90;c++)
    {// upper case letters
        sbB4symbols.append(c);
    }
    for( int c=97;c<=126;c++)
    {// lower case letters + some symbols
        sbB4symbols.append(c);
    }

    std::string base64Figures( sbB4symbols.str() );
    std::map<char,int> * base64Map = new std::map<char,int>();
    for( int c=0; c<base64Figures.size(); c++)
    {
        (*base64Map)[base64Figures[c]]= c;
    }

    for( std::map<char,int>::const_iterator reader=base64Map->begin();
         reader != base64Map->end();
         reader++ )
         {
             std::cout<< (*reader).first<<"  "<< (*reader).second<<std::endl;
         }

    unsigned long decimalQuantity = 0;// init and sum on it.
    std::string * cleanVersion = Common::StrManipul::replaceAllOccurencesOf("b64_",base64par,"");
    int abacusLeftMostPosition = cleanVersion->size()-1;// zero based
    for( int c=0 ;abacusLeftMostPosition>=0; abacusLeftMostPosition--,c++)
    {
        unsigned long figureQuantity = (*base64Map)[ (*cleanVersion)[c]];// value of the symbol.
        double abacusPositionQuantity = pow( +64.0 , (double)abacusLeftMostPosition );
        figureQuantity *= abacusPositionQuantity;
        decimalQuantity += figureQuantity;
    }
    delete cleanVersion;
    //ready.
    return decimalQuantity;
}

}// Development
}// MonteCarloNamespace
}// Common


    std::string * converted =
    Common::MonteCarloNamespace::Development::base64ConverterTo( 4294967295);// max(unsigned long)
    std::cout<<"dec 64 == B64 "<< *converted<<std::endl;

    unsigned long backFromB64 =// NB. avoid backSlashes due to escape sequences.
     Common::MonteCarloNamespace::Development::base10ConverterTo( *converted);
    delete converted;

    converted =
    Common::MonteCarloNamespace::Development::base64ConverterTo( backFromB64);
    std::cout<<"dec 64 == B64 "<< *converted<<std::endl;

    converted =
     Common::MonteCarloNamespace::Development::exadecimalConverterTo( 9898798);
    std::cout<<"dec 9898798 == B16 "<< *converted<<std::endl;
    delete converted;

    std::cout<<"sizeof(unsigned long) : "<<sizeof(unsigned long)<<std::endl;
    std::cout<<"sizeof(unsigned short) : "<<sizeof(unsigned short)<<std::endl;
    std::cout<<"sizeof(unsigned char) : "<<sizeof(unsigned char)<<std::endl;
//    unsigned long  Data1;  4 bytes == 32bit
//    unsigned short Data2;  2 == 16bit
//    unsigned short Data3;  2
//    unsigned char  Data4[8]; 1x8 == 64bit

//    int input =0;
//    for(;;)
//    {
//        std::cout << "Enter decimal number: " ;
//        std::cin >> input ;
//        if( 0 > input) {break;}
//        std::cout << "0x" << std::hex << input << '\n' ;
//    }



    double left  = +2.0;
    double right = +5.0;
    int populationCardinality = 4;
    double eta = +0.5;
    //
    Common::MonteCarloNamespace::Development::MonteCarloGenerator * monteCGen =
    new Common::MonteCarloNamespace::Development::MonteCarloGenerator(
                        left,true
                        ,right,true
                        ,true // is_continuous
                         );
    for( int c=0; c<populationCardinality;c++)
    {
        //monteCGen->nextIntegerInInterval();
        monteCGen->nextDoubleInInterval();
    }
    monteCGen->showPopulation();
    monteCGen->buildOmega( left, right, eta);
    monteCGen->buildFrequencyDistribution();
    monteCGen->showFrequencyDistribution();
    monteCGen->showCumulatedFrequency();

    delete monteCGen;

    //Common::Stream::showASCII();

//    for( int c=32; c<127; c++)
//    {
//        std::string * strASCIIcode = Common::StrManipul::intToString( c);
//        std::string * strASCIIsymb = Common::StrManipul::charToString( c);
//        //
//        std::cout<< " ASCII code "+ *strASCIIcode
//        + " corresponds to symbol : "
//        + *strASCIIsymb
//        << std::endl;
//        //
//        delete strASCIIcode;// free at each step, the allocated memory.
//        delete strASCIIsymb;
//    }// for


//    Common::dbCall::cantiere_numericTable_INSERT_SINGLE( -5.67005 );
//    Common::dbCall::cantiere_sede_INSERT_SINGLE();
//    Common::dbCall::cantiere_sede_LOAD_MULTI_();


//    boost_test();

    // Common::command_PREPARE(); tested : hangs with noexcept.

//    Entity::Integration::rettangoli( +100.0,
//                                     +120.0,
//                                     28,
//                                     f
//                                     , false // i.e. not called from inside "trapezi"
//                                     );
//
//    Entity::Integration::trapezi( +100.0,
//                                     +120.0,
//                                     28,
//                                     f
//                                     );

    // sqlParameters();
    //preparedStatement();
//    Process::testCpp11_MonteCarlo();



//    Common::MonteCarlo * mcInitializer = new Common::MonteCarlo();// time based seed.
//    int min = +2;
//    int sup = +4;
//    std::string * minStr = Common::StrManipul::intToString( min);
//    std::string * maxStr = Common::StrManipul::intToString( sup-1);
//    for( int c=0; c<20; c++)
//    {
//        std::string * tmp = Common::StrManipul::intToString(mcInitializer->nextIntegerInInterval( min, sup));
//        std::cout<< "int in ["+ *minStr +", "+ *maxStr +"] : " + *tmp <<std::endl;
//        delete tmp;
//    }
//    delete minStr;
//    delete maxStr;
//    delete mcInitializer;

Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.

The MySQL Connector/C++ is licensed under the terms of the GPLv2
<http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
MySQL Connectors. There are special exceptions to the terms and
conditions of the GPLv2 as it is applied to this software, see the
FLOSS License Exception
<http://www.mysql.com/about/legal/licensing/foss-exception.html>.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

//
//
///**
//* Example of statements - not to be confused with prepared statements
//*
//* NOTE: The MySQL Server does not support each and every SQL statement
//* to be prepared. The list of statements which can be prepared is available
//* in the MySQL Server documentation and the C API documentation:
//* http://dev.mysql.com/doc/refman/5.1/en/c-api-prepared-statements.html
//* (Link to the MySQL Server 5.1 documentation!)
//*
//* Connector/C++ is based on the C API and C library "libmysql". Therefore
//* it inherits all limitations from the MySQL Server and the MySQL C API.
//*
//* MySQL 5.1.12 can prepare the following statements:
//*
//* - CREATE TABLE, DELETE, DO, INSERT, REPLACE, SELECT, SET, UPDATE
//* - most SHOW commands
//* - ANALYZE TABLE, OPTIMIZE TABLE, REPAIR TABLE
//* - CACHE INDEX, CHANGE MASTER, CHECKSUM {TABLE | TABLES},
//* - {CREATE | RENAME | DROP} DATABASE, {CREATE | RENAME | DROP} USER
//* - FLUSH {TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES | LOGS | STATUS | MASTER | SLAVE | DES_KEY_FILE | USER_RESOURCES}
//* - GRANT, REVOKE, KILL, LOAD INDEX INTO CACHE, RESET {MASTER | SLAVE | QUERY CACHE}
//* - SHOW BINLOG EVENTS, SHOW CREATE {PROCEDURE | FUNCTION | EVENT | TABLE | VIEW}
//* - SHOW {AUTHORS | CONTRIBUTORS | WARNINGS | ERRORS}
//* - SHOW {MASTER | BINARY} LOGS, SHOW {MASTER | SLAVE} STATUS
//* - SLAVE {START | STOP}, INSTALL PLUGIN, UNINSTALL PLUGIN
//*
//*  ... that's pretty much every *core* SQL statement - but not USE as you'll see below.
//*
//* Connector/C++ does not include a prepared statement emulation
//*
//* @link http://dev.mysql.com/doc/refman/5.1/en/c-api-prepared-statements.html
//*/
//
///* Standard C++ includes */
//#include <stdlib.h>
//#include <iostream>
//#include <sstream>
//#include <stdexcept>
//
///*
//  Public interface of the MySQL Connector/C++.
//  You might not use it but directly include directly the different
//  headers from cppconn/ and mysql_driver.h + mysql_util.h
//  (and mysql_connection.h). This will reduce your build time!
//*/
//#include <driver/mysql_public_iface.h>
///* Connection parameter and sample data */
//#include "examples.h"
//
//bool prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql);
//sql::Statement* emulate_prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql);
//
//using namespace std;
//
//int prepareExample(int argc, const char **argv)
//{
//	static const string url(argc >= 2 ? argv[1] : EXAMPLE_HOST);
//	static const string user(argc >= 3 ? argv[2] : EXAMPLE_USER);
//	static const string pass(argc >= 4 ? argv[3] : EXAMPLE_PASS);
//	static const string database(argc >= 5 ? argv[4] : EXAMPLE_DB);
//
//	/* Driver Manager */
//	sql::Driver *driver;
//	/* sql::ResultSet.rowsCount() returns size_t */
//	size_t row;
//	stringstream sql;
//	stringstream msg;
//	int i, num_rows;
//
//	cout << boolalpha;
//	cout << "1..1" << endl;;
//	cout << "# Connector/C++ prepared statement example.." << endl;
//
//	try {
//		/* Using the Driver to create a connection */
//		driver = sql::mysql::get_driver_instance();
//		std::auto_ptr< sql::Connection > con(driver->connect(url, user, pass));
//
//		/* The usage of USE is not supported by the prepared statement protocol */
//		std::auto_ptr< sql::Statement > stmt(con->createStatement());
//		stmt->execute("USE " + database);
//
//		/*
//		Prepared statement are unhandy for queries which you execute only once!
//
//		prepare() will send your SQL statement to the server. The server
//		will do a SQL syntax check, perform some static rewriting like eliminating
//		dead expressions such as "WHERE 1=1" and simplify expressions
//		like "WHERE a > 1 AND a > 2" to "WHERE a > 2". Then control gets back
//		to the client and the server waits for execute() (or close()).
//		On execute() another round trip to the server is done.
//
//		In case you execute your prepared statement only once - like shown below -
//		you get two round trips. But using "simple" statements - like above - means
//		only one round trip.
//
//		Therefore, the below is *bad* style. WARNING: Although its *bad* style,
//		the example program will continue to do it to demonstrate the (ab)use of
//		prepared statements (and to prove that you really can do more than SELECT with PS).
//		*/
//		std::auto_ptr< sql::PreparedStatement > prep_stmt(con->prepareStatement("DROP TABLE IF EXISTS test"));
//		prep_stmt->execute();
//
//		prepare_execute(con, "CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, label CHAR(1))");
//		cout << "#\t Test table created" << endl;
//
//		/*
//		The first useful example - prepare() once, execute() n + 1 times
//		NOTE: The MySQL Server does not support named parameters. You have to use
//		the placeholder syntax shown below. There is no emulation which would you
//		allow to use named parameter like ':param1'. Use '?'. Parameters are 1-based.
//		*/
//		num_rows = 0;
//		prep_stmt.reset(con->prepareStatement("INSERT INTO test(id, label) VALUES (?, ?)"));
//		for (i = 0; i < EXAMPLE_NUM_TEST_ROWS; i++) {
//			prep_stmt->setInt(1, test_data[i].id);
//			prep_stmt->setString(2, test_data[i].label);
//			/* executeUpdate() returns the number of affected = inserted rows */
//			num_rows += prep_stmt->executeUpdate();
//		}
//
//		if (EXAMPLE_NUM_TEST_ROWS != num_rows) {
//			msg.str("");
//			msg << "Expecting " << EXAMPLE_NUM_TEST_ROWS << "rows, reported " << num_rows;
//			throw runtime_error(msg.str());
//		}
//		cout << "#\t Test table populated" << endl;
//
//		/* We will reuse the SELECT a bit later... */
//		std::auto_ptr< sql::PreparedStatement > prep_select(con->prepareStatement("SELECT id, label FROM test ORDER BY id ASC"));
//		cout << "#\t Running 'SELECT id, label FROM test ORDER BY id ASC'" << endl;
//		std::auto_ptr< sql::ResultSet > res(prep_select->executeQuery());
//		row = 0;
//		while (res->next()) {
//			cout << "#\t\t Row " << row << " - id = " << res->getInt("id");
//			cout << ", label = '" << res->getString("label") << "'" << endl;
//			row++;
//		}
//		res.reset(NULL);
//
//		if (EXAMPLE_NUM_TEST_ROWS != row) {
//			msg.str("");
//			msg << "Expecting " << EXAMPLE_NUM_TEST_ROWS << "rows, reported " << row;
//			throw runtime_error(msg.str());
//		}
//
//		cout << "#\t Simple PS 'emulation' for USE and another SELECT" << endl;
//		stmt.reset(emulate_prepare_execute(con, string("USE " + database).c_str()));
//		stmt.reset(emulate_prepare_execute(con, string("USE " + database).c_str()));
//
//		stmt.reset(emulate_prepare_execute(con, "SELECT id FROM test ORDER BY id ASC"));
//		res.reset(stmt->getResultSet());
//		if (res.get() != NULL) {
//			row = 0;
//			while (res->next()) {
//				cout << "#\t\t Row " << row << " - id = " << res->getInt("id") << endl;
//				row++;
//			}
//			res.reset(NULL);
//		}
//		stmt.reset(NULL);
//
//		/* Running the SELECT again but fetching in reverse order */
//		cout << "#\t SELECT and fetching in reverse order" << endl;
//
//		res.reset(prep_select->executeQuery());
//		row = res->rowsCount();
//		cout << "#\t\t res->getRowsCount() = " << res->rowsCount() << endl;
//		if (res->rowsCount() != EXAMPLE_NUM_TEST_ROWS) {
//			msg.str("");
//			msg << "Expecting " << EXAMPLE_NUM_TEST_ROWS << "rows, found " << res->rowsCount();
//			throw runtime_error(msg.str());
//		}
//
//		/* Position the cursor after the last row */
//		cout << "#\t\t Position the cursor after the last row\n";
//		res->afterLast();
//		cout << "#\t\t res->isafterLast()\t= " << res->isAfterLast() << endl;
//		cout << "#\t\t res->isLast()\t\t= " << res->isLast() << endl;
//		if (!res->isAfterLast() || res->isLast())
//			throw runtime_error("Moving the cursor after the last row failed");
//
//		while (res->previous()) {
//			cout << "#\t\t res->previous()\n";
//			cout << "#\t\t Row " << row << " - id = " << res->getInt("id");
//			cout << ", label = '" << res->getString("label") << "'" << endl;
//			row--;
//		}
//		cout << "#\t\t Should be before the first\n";
//		cout << "#\t\t res->isFirst()\t\t= " << res->isFirst() << endl;
//		cout << "#\t\t res->isBeforeFirst()\t= " << res->isBeforeFirst() << endl;
//		if (res->isFirst() || !res->isBeforeFirst())
//			throw runtime_error("Cursor should be before first row");
//
//		/* Now that the cursor is before the first, fetch the first */
//		cout << "#\t\t Now that the cursor is before the first, fetch the first\n";
//		cout << "#\t\t calling next() to fetch first row" << endl;
//		row++;
//		res->next();
//		cout << "#\t\t res->isFirst()\t\t= " << res->isFirst() << endl;
//		cout << "#\t\t Row " << row << " - id = " << res->getInt("id");
//		cout << ", label = '" << res->getString("label") << "'" << endl;
//		row--;
//
//		/* For more on cursors see resultset.cpp example */
//
//		/* Clean up */
//		res.reset(NULL);
//		stmt.reset(con->createStatement());
//		stmt->execute("DROP TABLE IF EXISTS test");
//		cout << "#done!" << endl;
//
//	} catch (sql::SQLException &e) {
//		/*
//		The MySQL Connector/C++ throws three different exceptions:
//
//		- sql::MethodNotImplementedException (derived from sql::SQLException)
//		- sql::InvalidArgumentException (derived from sql::SQLException)
//		- sql::SQLException (derived from std::runtime_error)
//		*/
//		cout << endl;
//		cout << "# ERR: DbcException in " << __FILE__;
//		cout << "(" << EXAMPLE_FUNCTION << ") on line " << __LINE__ << endl;
//		/* Use what(), getErrorCode() and getSQLState() */
//		cout << "# ERR: " << e.what();
//		cout << " (MySQL error code: " << e.getErrorCode();
//		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//
//		if (e.getErrorCode() == 1047) {
//			/*
//			Error: 1047 SQLSTATE: 08S01 (ER_UNKNOWN_COM_ERROR)
//			Message: Unknown command
//			*/
//			cout << "# ERR: Your server seems not to support PS at all because its MYSQL <4.1" << endl;
//		}
//		cout << "not ok 1 - examples/prepared_statement.cpp" << endl;
//
//		return EXIT_FAILURE;
//	} catch (std::runtime_error &e) {
//
//		cout << endl;
//		cout << "# ERR: runtime_error in " << __FILE__;
//		cout << "(" << EXAMPLE_FUNCTION << ") on line " << __LINE__ << endl;
//		cout << "# ERR: " << e.what() << endl;
//		cout << "not ok 1 - examples/prepared_statement.cpp" << endl;
//
//		return EXIT_FAILURE;
//	}
//
//	cout << "ok 1 - examples/prepared_statement.cpp" << endl;
//	return EXIT_SUCCESS;
//}
//
//
//bool prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql)
//{
//	sql::PreparedStatement * prep_stmt;
//
//	prep_stmt = con->prepareStatement(sql);
//	prep_stmt->execute();
//	delete prep_stmt;
//
//	return true;
//}
//
//
//sql::Statement* emulate_prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql)
//{
//	sql::PreparedStatement *prep_stmt;
//	sql::Statement *stmt = NULL;
//
//	cout << "#\t\t 'emulation': " << sql << endl;
//
//	try {
//
//		prep_stmt = con->prepareStatement(sql);
//		prep_stmt->execute();
//		cout << "#\t\t 'emulation': use of sql::PreparedStatement possible" << endl;
//		/* safe upcast - PreparedStatement is derived from Statement */
//		stmt = prep_stmt;
//
//	} catch (sql::SQLException &e) {
//		/*
//		Maybe the command is not supported by the MySQL Server?
//
//		http://dev.mysql.com/doc/refman/5.1/en/error-messages-server.html
//		Error: 1295 SQLSTATE: HY000 (ER_UNSUPPORTED_PS)
//
//		Message: This command is not supported in the prepared statement protocol yet
//		*/
//
//		if (e.getErrorCode() != 1295) {
//			// The MySQL Server should be able to prepare the statement
//			// but something went wrong. Let the caller handle the error.
//			throw ;
//		}
//		cout << "#\t\t 'emulation': ER_UNSUPPORTED_PS and fallback to sql::Statement" << endl;
//		cout << "#\t\t ERR: " << e.what();
//		cout << " (MySQL error code: " << e.getErrorCode();
//		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//
//		stmt = con->createStatement();
//		stmt->execute(sql);
//	}
//
//	return stmt;
//}

void sqlParameters()
{
    sql::Driver *driver;
    sql::Connection *con;
    sql::PreparedStatement *prep_stmt = nullptr;
    //
    driver = get_driver_instance();// get the driver
    con = driver->connect("tcp://127.0.0.1:3306", "root", "Riemann0");
    //
    sql::SQLString * mySqlString = new sql::SQLString("cantiere");
    prep_stmt = con->prepareStatement( "INSERT INTO cantiere.sede(Baustelle_name, role, set_by) VALUES ( ?, ?, ?)");
    //
    //--preparing for first usage:
    prep_stmt->setString(1, "nomeCantiere_uno");
    prep_stmt->setString(2, "ruoloSede_uno");
    prep_stmt->setString(3, "collaboratoreSottoscrittore_uno");
    prep_stmt->execute();//-- first usage.
    //
    //--preparing for second usage:
    prep_stmt->setString(1, "nomeCantiere_due");
    prep_stmt->setString(2, "ruoloSede_due");
    prep_stmt->setString(3, "collaboratoreSottoscrittore_due");
    prep_stmt->execute();//-- second usage.
    //
    // ready : clean up now.
//    delete prep_stmt;
    delete con;
}// end sqlParameters()



void preparedStatement()
{
cout << endl;
cout << "Let's have MySQL count from 10 to 1..." << endl;

try {
  sql::Driver *driver;
  sql::Connection *con;
  sql::Statement *stmt;
  sql::ResultSet *res;
  sql::PreparedStatement *pstmt;

  //  Create a connection
  driver = get_driver_instance();
  con = driver->connect("tcp://127.0.0.1:3306", "root", "Riemann0");
  // Connect to the MySQL test database
//con->setSchema("test");

  stmt = con->createStatement();
  stmt->execute("DROP TABLE IF EXISTS cantiere.test");
  stmt->execute("CREATE TABLE cantiere.test(id INT)");
  delete stmt;

  /* '?' is the supported placeholder syntax */
  pstmt = con->prepareStatement("INSERT INTO cantiere.test(id) VALUES (?)");
  for (int i = 1; i <= 10; i++) {
    pstmt->setInt(1, i);
    pstmt->executeUpdate();
  }
  delete pstmt;

  /* Select in ascending order */
  pstmt = con->prepareStatement("SELECT id FROM test ORDER BY id ASC");
  res = pstmt->executeQuery();

  /* Fetch in reverse = descending order! */
  res->afterLast();
  while (res->previous())
    cout << "\t... MySQL counts: " << res->getInt("id") << endl;
  delete res;

  delete pstmt;
  delete con;

} catch (sql::SQLException &e) {
  cout << "# ERR: SQLException in " << __FILE__;
  cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
  cout << "# ERR: " << e.what();
  cout << " (MySQL error code: " << e.getErrorCode();
  cout << ", SQLState: " << e.getSQLState() << " )" << endl;
}

cout << endl;
}

//
//int OracleSuggests()
//{
//    cout << endl;
//    cout << "Running 'SELECT 'Hello World!' AS _message'..." << endl;
//
//    try
//    {
//        sql::Driver *driver;
//        sql::Connection *con;
//        sql::Statement *stmt;
//        sql::ResultSet *res;
//
//        // Create a connection : steps follow:
//        driver = get_driver_instance();// get the driver
//        con = driver->connect( "tcp://127.0.0.1:3306", "root", "Riemann0");// get the connection to the specified instance.
//        //con = driver->connect( "tcp://Eulero:3306", "root", "Riemann0");// get the connection to the specified instance.
//        // con->setAutoCommit( false);
//        //con->setAutoCommit( true);
//        //con->setSchema("cantiere");// choose which database, within the instance.
//        //
//        // execute something, with the current connection:
//        stmt = con->createStatement();// prepare a statement
//        res = stmt->executeQuery("SELECT 'Hello World!' AS _message");// execute the statement
//        //
//        //-------fetch the resultset--------------------
//        while (res->next())
//        {
//            cout << "\t... MySQL replies: ";
//            // Access column data by alias or column name
//            cout << res->getString("_message") << endl;
//            cout << "\t... MySQL says it again: ";
//            // Access column data by numeric offset, 1 is the first column
//            cout << res->getString(1) << endl;
//        }//--END-----fetch the resultset--------------------
//        //--- cleanup------
//        delete res;
//        delete stmt;
//        delete con;
//    }// END try
//    catch( sql::SQLException &e)
//    {
//        cout << "# ERR: SQLException in " << __FILE__;
//        cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
//        cout << "# ERR: " << e.what();
//        cout << " (MySQL error code: " << e.getErrorCode();
//        cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//    }// END catch( sql::SQLException &e)
//    catch( const std::exception& ex)
//    {
//        std::string HappenedException = ex.what();
//    }
//    catch (const std::string& ex)
//    {
//        std::string HappenedException = ex.c_str();
//    }
//    catch(...)
//    {
//        std::string HappenedException = "this was (sadly) an unnamed exception, which -therefore- has no content.";
//    }// END catch(...)
//
//    // ready.
//    cout << endl;
//    getchar();
//    return EXIT_SUCCESS;
//}// end OracleSuggests.
//
//
//
//
//int cantiere_sede_SELECT_MULTI_(void)
//{
//    cout << endl;
//    cout << " cantiere_sede_SELECT_MULTI_ : " << endl;
//    int rowCard  = 0;
//
//    try
//    {
//        sql::Driver *driver;
//        sql::Connection *con;
//        sql::Statement *stmt;
//        sql::ResultSet *res;
//
//        // Create a connection : steps follow:
//        driver = get_driver_instance();// get the driver
//        con = driver->connect( "tcp://127.0.0.1:3306", "root", "Riemann0");// get the connection to the specified instance.
//        //con = driver->connect( "tcp://Eulero:3306", "root", "Riemann0");// get the connection to the specified instance.
//        // con->setAutoCommit( false);
//        //con->setAutoCommit( true);
//        //con->setSchema("cantiere");// choose which database, within the instance.
//        //
//        // execute something, with the current connection:
//        stmt = con->createStatement();// prepare a statement
////res = stmt->executeQuery("SELECT * from cantiere.sede");// execute the statement
//        res = stmt->executeQuery("call cantiere.usp_SEDE_LOAD_MULTI");// execute the statement
//        //
//        //-------fetch the resultset--------------------
//        while( res->next() )
//        {
//            cout << "\t... MySQL replies: ";
//            cout << res->getString("id") << "   ";// Access column data by alias or column name
//            cout << res->getString("Baustelle_name") << "   ";// Access column data by alias or column name
//            cout << res->getString("role") << "   ";// Access column data by alias or column name
//            cout << res->getString("set_time") << "   ";// Access column data by alias or column name
//            cout << res->getString("set_by") << endl;// Access column data by alias or column name // NewLine on end of Record (which is a table's line).
//            //cout << res->getString(1) << endl;// Access column data by numeric offset, 1 is the first column
//            ++rowCard;// done a line.
//        }//--END-----fetch the resultset--------------------
//        //
//        std::cout << "\n\n\t Processed lines # " << rowCard << std::endl;
//        //--- cleanup------
//        delete res;
//        delete stmt;
//        if( ! con->isClosed() )
//        {
//            con->close();
//        }// else already closed.
//        delete con;
//    }// END try
//    catch( sql::SQLException &e)
//    {
//        cout << "# ERR: SQLException in " << __FILE__;
//        cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
//        cout << "# ERR: " << e.what();
//        cout << " (MySQL error code: " << e.getErrorCode();
//        cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//    }// END catch( sql::SQLException &e)
//    catch( const std::exception& ex)
//    {
//        std::string HappenedException = ex.what();
//    }
//    catch (const std::string& ex)
//    {
//        std::string HappenedException = ex.c_str();
//    }
//    catch(...)
//    {
//        std::string HappenedException = "this was (sadly) an unnamed exception, which -therefore- has no content.";
//    }// END catch(...)
//
//    // ready.
//    cout << endl;
//    return rowCard;
//}// end cantiere_sede_SELECT_MULTI_
//
//
//
//
//int cantiere_sede_INSERT_SINGLE(void)
//{
//    cout << endl;
//    cout << " cantiere_sede_INSERT_SINGLE : " << endl;
//    bool insertionHasError;// insertion result
//
//    try
//    {
//        sql::Driver *driver;
//        sql::Connection *con;
//        sql::Statement *stmt;
//
//        // Create a connection : steps follow:
//        driver = get_driver_instance();// get the driver
//        con = driver->connect( "tcp://127.0.0.1:3306", "root", "Riemann0");// get the connection to the specified instance.
//        //
//        // execute something, with the current connection:
//        stmt = con->createStatement();// prepare a statement
//        const std::string theStatement = "call cantiere.usp_SEDE_INSERT_SINGLE ('sixth_fromCPP','sixth_fromCPP','sixth_fromCPP')";
////con->
////stmt->
////driver->
//        insertionHasError = stmt->execute( theStatement);// execute the statement
//        //
//        //--- cleanup------
//        delete stmt;
//        if( ! con->isClosed() )
//        {
//            con->close();
//        }// else already closed.
//        delete con;
//    }// END try
//    catch( sql::SQLException &e)
//    {
//        cout << "# ERR: SQLException in " << __FILE__;
//        cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
//        cout << "# ERR: " << e.what();
//        cout << " (MySQL error code: " << e.getErrorCode();
//        cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//    }// END catch( sql::SQLException &e)
//    catch( const std::exception& ex)
//    {
//        std::string HappenedException = ex.what();
//    }
//    catch (const std::string& ex)
//    {
//        std::string HappenedException = ex.c_str();
//    }
//    catch(...)
//    {
//        std::string HappenedException = "this was (sadly) an unnamed exception, which -therefore- has no content.";
//    }// END catch(...)
//
//    // ready.
//    cout << endl;
//    return insertionHasError;// false on insertionSuccess( 1 row i.e. INSERT_SINGLE), ture on error.
//}// end cantiere_sede_INSERT_SINGLE



//class HandledProto
//{
//private:
//    int * handledData;
//    const int dataCard = 16;
//
//public:
//    HandledProto()
//    {
//        handledData = (int *)new int[dataCard];
//        for(int c=0; c<dataCard; c++)
//        {
//            handledData[c] = c;
//        }
//    }
//
//    HandledProto( const HandledProto &other)
//    {
//        this->handledData = other.handledData;
//    }
//
//    /*
//    HandledProto( HandledProto &&ancestor)
//    {
//        this->handledData = std::move( ancestor);
//    }*/
//};
//
//
//void testExcept()
//{
//    try
//    {
//        int i=5;
//        ++i;
//        throw i;
//    }
//    catch(int i)
//    {
//        std::cout << "caught " << i << std::endl;
//    }
//    catch(...)
//    {
//        std::cout << "caught generic exception." << std::endl;
//    }
//}


//    std::string original = "Nel mezzo #f# #f# #f#  #f# del cammin #f# di nostra vita #f# #f# mi ritrovai per una selva oscura #f# #f# #f#.";
//    std::cout << "original = ";
//    std::cout << original << std::endl;
//
//    std::string * tmp = Common::StrManipul::replaceAllOccurencesOf("#f#",
//        original,
//        "_thisWasAToken_" );
//    std::cout << "after replacement = " << *tmp << std::endl;
//    delete tmp;
//    std::cout << "original = ";
//    std::cout << original << std::endl;
//
//    std::vector<std::string> * theDirtyTokens = Common::StrManipul::stringSplit(
//     "#f#", "Nel mezzo #f# #f# #f#  #f# del cammin #f# di nostra vita #f# #f# mi ritrovai per una selva oscura #f# #f# #f#.",
//     false);
//    for( std::vector<std::string>::iterator it=theDirtyTokens->begin();
//         it != theDirtyTokens->end();
//         it++
//    )
//    {
//        std::cout << *it << std::endl;
//    }
//    delete theDirtyTokens;
//    //
//    std::cout << "\n\n" << std::endl;
//    std::vector<std::string> * theTokens = Common::StrManipul::stringSplit(
//     "#f#", "Nel mezzo #f# #f# #f#  #f# del cammin #f# di nostra vita #f# #f# mi ritrovai per una selva oscura #f# #f# #f#.",
//     true);
//    for( std::vector<std::string>::iterator it=theTokens->begin();
//         it != theTokens->end();
//         it++
//    )
//    {
//        std::cout << Common::StrManipul::trimBoth( *it) << std::endl;
//    }
//    delete theTokens;
//
//
//    // testExcept();
//
//    Process::testMonteCarlo();



//
//    TestSplit::MemCaleeCaller * m = new TestSplit::MemCaleeCaller();
//    std::vector<std::string> * res = m->stringSplit_withAllocation("#","Nel # mezzo # del # cammin", false);
//    for( std::vector<std::string>::iterator it=res->begin(); it!=res->end(); it++)
//    {
//        std::cout << *it << "\n";
//    }
//    //--------------------
//    std::cout << "\n\n\n";
//    std::vector<std::string> * IOres = new std::vector<std::string>();
//    m->stringSplit_withoutAlloc("#","Nel # mezzo # del # cammin", *IOres, false);
//    for( std::vector<std::string>::iterator it=IOres->begin(); it!=IOres->end(); it++)
//    {
//        std::cout << *it << "\n";
//    }
//    //
//    delete res;
//    delete IOres;
//    delete m;
//
//    logTest_monothread_();// mono_thread.
//    //
//    int nThreads = 3;
//    std::thread threads[nThreads];
//    // spawn nThreads threads:
//    for (int i=0; i<nThreads; ++i)
//    {
//        threads[i] = std::thread(EntryPointThreadSpawn_TraceOnly_, i+1);
//    }
//    //
//    for (auto& th : threads)
//    {
//        th.join();
//    }
//

//
//    configFileTestGenerator();
//
//    Common::ConfigurationService * cs = Process::getDefaultConfiguration();// AppConfig.txt
//    if( nullptr == cs)
//    {
//        return -1;
//    }
//    std::vector<std::string> * theKeys = cs->getAllKeys();
//    int ckey=0;
//    for( std::vector<std::string>::iterator keysIter=theKeys->begin(); keysIter!=theKeys->end(); keysIter++)
//    {
//        std::cout<<" chiave nr. "<< ++ckey <<"  "<< (*keysIter).c_str() << std::endl;
//    }
//    theKeys->clear();
//    delete theKeys;
//    //
//    std::string * obtainedVal = nullptr;
//    for(std::string user_key="start"; 0!=std::string("exit").compare(user_key); )
//    {
//        std::cout <<"\n\t Enter a key (type exit to leave). ";
//        std::cin >> user_key;
//        obtainedVal = cs->getValue( user_key);
//        std::cout<<"\t user_key \t"<< user_key << " value= " << *obtainedVal << std::endl;
//        delete obtainedVal;// because it's NEW at every loop-step.
//    }
//    // ready.
//    delete cs;// del Configuration instance.
//
//
//
////    std::string test = "       Una vita in vacanza pazza       Nel mezzo del cammin di pazza    pazza    pazza pazza nostra vita pazza       Integral massa raggio quadro     ";
////    std::cout << "_";
////    std::cout << test;
////    std::cout << "_" << std::endl;
//
//
//    bool isInvisible = isInvisibleString( test);
//    isInvisible = isInvisibleString( "           ");
//
//    std::cout << "_";
//    std::cout << trimBoth( test);
//    std::cout << "_" << std::endl;
//
//
////
////    std::vector<std::string> * res = stringSplit( "pazza", test );// NB. original passed by value, to be preserved.
////
////    for( std::vector<std::string>::iterator vecPtr=res->begin(); vecPtr!=res->end(); vecPtr++)
////    {
////        std::cout << "\n\t " << *vecPtr << std::endl;
////    }
////    std::cout << "\n######   withNoEmpties   ######\n" << std::endl;
////    std::vector<std::string> * withNoEmpties = stringSplit( "pazza", test, true );// NB. original passed by value, to be preserved.
////    for( std::vector<std::string>::iterator withNoEmptiesPtr=withNoEmpties->begin(); withNoEmptiesPtr!=withNoEmpties->end(); withNoEmptiesPtr++)
////    {
////        std::cout << "\n\t " <<   *withNoEmptiesPtr << std::endl;
////    }
////    std::cout << "\n######   withNoEmpties neither Invisibles  ######\n" << std::endl;
////    for( std::vector<std::string>::iterator withNoEmptiesPtr=withNoEmpties->begin(); withNoEmptiesPtr!=withNoEmpties->end(); withNoEmptiesPtr++)
////    {
////        std::cout << "\n\t " <<   trimBoth(*withNoEmptiesPtr) << std::endl;
////    }
////
////    delete res;
////    delete withNoEmpties;
//
//
//
////    std::string tokenToBeReplaced = "pazza";
////    std::cout << replaceAllOccurencesOf( "pazza", test, "#" ) << std::endl;
//
//
//
////    std::string modif_1 = test.replace( test.find("pazza") , 5, "#");
////    std::cout << modif_1 << std::endl;
////    //
////    std::string modif_2 = test.replace( test.find("pazza") , 5, "#");
////    std::cout << modif_2 << std::endl;
//
//     // Process_LogWrappers::JustConstructTEST("mmm", 0);
//
//    // logTest_monothread_();// mono_thread.
//
//
//	std::string thePath("./AppConfig.txt");
//	std::fstream theStream;
//	//
//    instream_getToken( thePath, theStream);
//
//
//    //OsservatoSpeciale();
//
//
//
//
//    /*
//	std::string thePath("./testConfig20180128_.txt");
//	std::fstream theStream;
//	//
//    instream_getToken( thePath, theStream);
//    */
//
//    /*
//    logTest_monothread_();// mono_thread.
//    //
//    int nThreads = 3;
//    std::thread threads[nThreads];
//    // spawn nThreads threads:
//    for (int i=0; i<nThreads; ++i)
//    {
//        threads[i] = std::thread(EntryPointThreadSpawn_TraceOnly_, i+1);
//    }
//    //
//    for (auto& th : threads)
//    {
//        th.join();
//    }
//    */
//
//
////namespace TestSplit
////{
////
////
////class MemCaleeCaller
////{
////    public:
////    std::vector<std::string> * stringSplit_withAllocation( const std::string &tokenToSplitOn, std::string original, bool removeEmptyEntries )// NB. original passed by value, to be preserved.
////    {
////        unsigned where = 0;
////        unsigned whereWeWere = 0;
////        // the return value is a vector, which contains as many strings, as there are in "original" between the occurences of "tokenToSplitOn".
////        std::vector<std::string> * returnValue = new std::vector<std::string>();
////        // core
////        do// core
////        {
////            where = original.find( tokenToSplitOn);
////            std::string tmp = original.substr( whereWeWere, where );
////            if( true==removeEmptyEntries)
////            {
////                if( false==Common::StrManipul::isInvisibleString( tmp) )
////                {
////                    returnValue->push_back( tmp );
////                }// END if( false==isInvisibleString( tmp) ) : else : skip an emptyEntry.
////            }// END if( true==removeEmptyEntries) : else : do not check for emptyEntries : just push them back along with the other entries.
////            else// else : do not check for emptyEntries : just push them back along with the other entries.
////            {// else : do not check for emptyEntries : just push them back along with the other entries.
////                returnValue->push_back( tmp );
////            }// END else : do not check for emptyEntries : just push them back along with the other entries.
////            original.replace( whereWeWere, where+tokenToSplitOn.size(), "");// eliminate the token that has been detached: do this anyway( i.e. removeEmptyEntries true or false).
////        }// END core
////        while( -1 != where);
////        // ready.
////        return returnValue;
////    }// END stringSplit_withAllocation
////
////
////    std::vector<std::string> & stringSplit_withoutAlloc(
////        const std::string &tokenToSplitOn,
////        std::string original,
////        std::vector<std::string> & preAllocatedReturnVal,
////        bool removeEmptyEntries )// NB. original passed by value, to be preserved.
////    {
////        unsigned where = 0;
////        unsigned whereWeWere = 0;
////        // the return value is a vector, which contains as many strings, as there are in "original" between the occurences of "tokenToSplitOn".
//////std::vector<std::string> * returnValue = new std::vector<std::string>(); NO MORE
////        // core
////        do// core
////        {
////            where = original.find( tokenToSplitOn);
////            std::string tmp = original.substr( whereWeWere, where );
////            if( true==removeEmptyEntries)
////            {
////                if( false==Common::StrManipul::isInvisibleString( tmp) )
////                {
////                    preAllocatedReturnVal.push_back( tmp );
////                }// END if( false==isInvisibleString( tmp) ) : else : skip an emptyEntry.
////            }// END if( true==removeEmptyEntries) : else : do not check for emptyEntries : just push them back along with the other entries.
////            else// else : do not check for emptyEntries : just push them back along with the other entries.
////            {// else : do not check for emptyEntries : just push them back along with the other entries.
////                preAllocatedReturnVal.push_back( tmp );
////            }// END else : do not check for emptyEntries : just push them back along with the other entries.
////            original.replace( whereWeWere, where+tokenToSplitOn.size(), "");// eliminate the token that has been detached: do this anyway( i.e. removeEmptyEntries true or false).
////        }// END core
////        while( -1 != where);
////        // ready.
////        return preAllocatedReturnVal;
////    }// END stringSplit_withoutAlloc
////
////};
////
////}// end nmsp TestSplit
//
////
/////   TODO : cercare il separatore '#'
////    controllare che siano uguali le cardinalita' di key e value
////    predisporre due vector<string> , una per key e una per value (stessa cardinalita' ! )
////    popolare la mappa, mediante le corrispondenze biunivoche [key, value]
////    comportarsi camera sterile
////
////
////bool OsservatoSpeciale()
////{
////    bool result = true; //instreamOpener( fullPath , theInStream );
////    std::fstream theInStream;
////    std::map<std::string, std::string> * this_key_val_map;
////    std::vector<std::string> * this_key_all_together;
////    theInStream.open( "./AppConfig.txt" , std::ios::in );
////    std::vector<std::string> * tokenArray = new std::vector<std::string>;
////    bool this_isHealtlyConstructed = true;
////    //
////    for( int c=0; !theInStream.eof();  )
////    {
////        std::string buf;// tmp for current token.
////        theInStream >> buf;// cosi' va per WORD separate da blank o TAB o new line
////        std::cout<<buf<<std::endl;
////        tokenArray->push_back( buf );
////        ++c;
////    }
////
////    int cardToken = tokenArray->size();// keys + '#' + values : must be n + 1 + n ==2*n+1 so odd (dispari).
////    double ratio = (double)cardToken / 2.0;
////    double fractionalPart = ratio - (int)ratio;
////    if( fabs(fractionalPart) < +1.0E-16 )// was even (pari) -> errore di configurazione (must be 2*n+1).
////    {
////        this_isHealtlyConstructed = false;
////        return (this_isHealtlyConstructed);
////    }// else can continue.
////    int candidateSeparatorPosition = (int)ratio+1;
////    if( ! ((std::string)((*tokenArray)[candidateSeparatorPosition])).compare("#") )
////    {
////        this_isHealtlyConstructed = false;
////        return (this_isHealtlyConstructed);
////    }// else can continue.
////    int c=0;
////    this_key_all_together = new std::vector<std::string>((int)ratio);// how many keys.
////    this_key_val_map = new std::map<std::string, std::string>();
////    int n = (int)ratio;
////    for(std::vector<std::string>::iterator curToken=tokenArray->begin(); curToken!=tokenArray->end(); curToken++)
////    {// indici [c] e [c+n+1] rispettivamente {chiave, valore} nel vector tokenArray.
////        this_key_all_together->push_back( *curToken );// push a key
////        (*(this_key_val_map))[*curToken] = (*(curToken+n+1)).c_str();// push such key together with its corresponding value, in the map.
////        c++;
////        if( n == c)// fondo corsa
////        {
////            break;// keys are over; their corresponfing values, have already been treated.
////        }// else have to continue.
////    }// end for each key.
////    // final usage of bool_result
////    result =instreamCloser( theInStream );
////    result &= (c>0);
////    std::cout<<"\n\n"<<std::endl;
////    for(std::vector<std::string>::iterator curToken=tokenArray->begin(); curToken!=tokenArray->end(); curToken++)
////    {
////        std::cout<<" key = "<< *curToken ;
////        std::cout<<" its value is "<< (*this_key_val_map)[(*curToken).c_str()]<<std::endl;
////        if( ! ((std::string)(*curToken)).compare("#") )
////        {
////            break;// END keys
////        }
////    }
////    std::cout<<"\n\n"<<std::endl;
////    delete tokenArray;
////    //
////    return result;
////}// end  OsservatoSpeciale
//
//
////    bool isConstructorStillAlive = true;
////    //
////    if(isConstructorStillAlive)
////    {// se esiste
////        if(2==2)//(exists)
////        {
////            isConstructorStillAlive = true;
////        }
////        else
////        {
////            isConstructorStillAlive = false;
////        }
////        if(isConstructorStillAlive)
////        {// se riesco ad aprirlo in lettura
////            if(2==2)//(getsOpen_read)
////            {
////                isConstructorStillAlive = true;
////            }
////            else
////            {
////                isConstructorStillAlive = false;
////            }
////            if(isConstructorStillAlive)
////            {// se la sua sintassi e' valida
////                if(2==3)//(has_valid_content)
////                {
////                    isConstructorStillAlive = true;
////                }
////                else
////                {
////                    isConstructorStillAlive = false;
////                }
////                if(isConstructorStillAlive)
////                {// popola la mappa
////                    if(2==2)//if(wasAbleToPopulateTheMap)
////                    {
////                        isConstructorStillAlive = true;
////                    }
////                    else
////                    {
////                        isConstructorStillAlive = false;
////                    }
////                }// END popola la mappa
////            }// END  se la sua sintassi e' valida
////        }// END   se riesco ad aprirlo in lettura
////    }// END  se esiste
////
//
///*
//
//int recursionLevel=0;
//
//void logTest_monothread_()
//{
//    Process_LogWrappers::SectionOpen("void logTest_1()", 0);
//    //
//    while(25>recursionLevel)
//    {
//        ++recursionLevel;
//        std::stringstream sStream;
//        sStream << recursionLevel;
//        std::string LogText("this is some content, logged from inside the current function. Recursion== " + sStream.str() );
//        Process_LogWrappers::SectionContent( LogText.c_str(), 0);
//        logTest_monothread_();
//    }
//    //
//    Process_LogWrappers::SectionClose();
//}
//
//std::mutex open_phase;
//std::mutex trace_phase_1_;
//std::mutex trace_phase_2_;
//std::mutex trace_phase_3_;
//std::mutex close_phase;
//
//void EntryPointThreadSpawn( int par)
//{
//    open_phase.lock();
//    {
//        std::stringstream thread_number_open;
//        thread_number_open << par;
//        //
//        std::vector<std::string> opener;
//        opener.push_back("EntryPointThreadSpawn");
//        opener.push_back(" thread_number= ");
//        opener.push_back(thread_number_open.str());
//        Process_LogWrappers::SectionOpen_multiMessage( opener, 0);
//        opener.clear();
//    }
//    open_phase.unlock();
//    //
//    trace_phase_1_.lock();
//    {
//        std::stringstream thread_number_t1;
//        thread_number_t1 << par;
//        //
//        std::vector<std::string> contentTracer_1;
//        contentTracer_1.push_back("Nel mezzo del cammin di nostra vita");
//        contentTracer_1.push_back(" thread_number= ");
//        contentTracer_1.push_back(thread_number_t1.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_1 , 0);
//        contentTracer_1.clear();
//    }
//    trace_phase_1_.unlock();
//    //
//    trace_phase_2_.lock();
//    {
//        std::stringstream thread_number_t2;
//        thread_number_t2 << par;
//        //
//        std::vector<std::string>  contentTracer_2;
//        contentTracer_2.push_back("Mi ritrovai per una selva oscura");
//        contentTracer_2.push_back(" thread_number= ");
//        contentTracer_2.push_back(thread_number_t2.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_2 , 0);
//        contentTracer_2.clear();
//    }
//    trace_phase_2_.unlock();
//    //
//    trace_phase_3_.lock();
//    {
//        std::stringstream thread_number__t3;
//        thread_number__t3 << par;
//        //
//        std::vector<std::string>  contentTracer_3;
//        contentTracer_3.push_back("che la diritta via era smarrita");
//        contentTracer_3.push_back(" thread_number= ");
//        contentTracer_3.push_back(thread_number__t3.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_3 , 0);
//        contentTracer_3.clear();
//    }
//    trace_phase_3_.unlock();
//    //
//    close_phase.lock();
//    {
//        Process_LogWrappers::SectionClose();
//    }
//    close_phase.unlock();
//    // ready.
//}// END EntryPointThreadSpawn
//
//
//void EntryPointThreadSpawn_TraceOnly_( int par)
//{
//    //
//    trace_phase_1_.lock();
//    {
//        std::stringstream thread_number_t1;
//        thread_number_t1 << par;
//        //
//        std::vector<std::string> contentTracer_1;
//        contentTracer_1.push_back("Nel mezzo del cammin di nostra vita");
//        contentTracer_1.push_back(" thread_number= ");
//        contentTracer_1.push_back(thread_number_t1.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_1 , 0);
//        contentTracer_1.clear();
//    }
//    trace_phase_1_.unlock();
//    //
//    trace_phase_2_.lock();
//    {
//        std::stringstream thread_number_t2;
//        thread_number_t2 << par;
//        //
//        std::vector<std::string>  contentTracer_2;
//        contentTracer_2.push_back("Mi ritrovai per una selva oscura");
//        contentTracer_2.push_back(" thread_number= ");
//        contentTracer_2.push_back(thread_number_t2.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_2 , 0);
//        contentTracer_2.clear();
//    }
//    trace_phase_2_.unlock();
//    //
//    trace_phase_3_.lock();
//    {
//        std::stringstream thread_number__t3;
//        thread_number__t3 << par;
//        //
//        std::vector<std::string>  contentTracer_3;
//        contentTracer_3.push_back("che la diritta via era smarrita");
//        contentTracer_3.push_back(" thread_number= ");
//        contentTracer_3.push_back(thread_number__t3.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_3 , 0);
//        contentTracer_3.clear();
//    }
//    trace_phase_3_.unlock();
//    // ready.
//}// END EntryPointThreadSpawn_TraceOnly_
//
//
//class SomeClass
//{
//private:
//    int i;
//    char c;
//    char * s;
//    int * ia;
//    std::string stdString;
//
//public:
//    SomeClass()
//    {
//        this->i = 1;
//        this->c = '2';
//        this->s = new char[10];
//        sprintf(this->s,"%s","abc");
//        this->s[3]=0;// terminate.
//        this->ia = new int[3]{1, 2, 3};
//        this->stdString = "this is a STL::string";
//    }
//    SomeClass(
//                    int i_par,
//                    char c_par,
//                    char * s_par,
//                    int * ia_par,
//                    std::string &stdString_par
//              )
//    {
//        this->i = i_par;
//        this->c = c_par;
//        this->s = s_par;
//        this->ia = ia_par;
//        this->stdString = stdString_par;
//    }
//    //
//    SomeClass(
//                bool wantInitList,// NB. #########################
//                    int i_par,
//                    char c_par,
//                    char * s_par,
//                    int * ia_par,
//                    std::string &stdString_par
//              ) :
//        i( i_par)
//        ,c( c_par)
//        ,s( s_par)
//        ,ia( ia_par)
//        ,stdString( stdString_par)
//    {
//    }
//
//};
//
//
////    bool isConstructorStillAlive=true;
////    std::string reasonForNotBeingAlive;
////
////    if(isConstructorStillAlive)
////    {//  first check
////        int i=44;
////        i++;
////        //##
////        if(isConstructorStillAlive)
////        {// check Configuration existence
////            --i;
////            if(3==i)
////            {
////                isConstructorStillAlive=false;
////                reasonForNotBeingAlive = "Configuration existence";
////            }
////            //##
////            if(isConstructorStillAlive)
////            {// check Configuration consistency
////                i+=5;
////                if(3==i)
////                {
////                    isConstructorStillAlive=false;
////                    reasonForNotBeingAlive = "Configuration consistency";
////                }
////                //##
////                if(isConstructorStillAlive)
////                {// check Configuration::semaphore
////                    i=3;
////                    if(3==i)
////                    {
////                        isConstructorStillAlive=false;
////                        reasonForNotBeingAlive = "Configuration::semaphore";
////                    }
////                    //##
////                    if(isConstructorStillAlive)
////                    {// check Configuration::verbosity
////                        if(3==i)
////                        {
////                            isConstructorStillAlive=false;
////                            reasonForNotBeingAlive = "Configuration::verbosity";
////                        }
////                        //##
////                        if(isConstructorStillAlive)
////                        {// check tryOpen
////                            if(3==i)
////                            {
////                                isConstructorStillAlive=false;
////                                reasonForNotBeingAlive = "tryOpen";
////                            }
////                        }// END check tryOpen
////                    }// END check check Configuration::verbosity
////                }// END check Configuration::semaphore
////            }// END check Configuration consistency
////        }// END check Configuration existence
////    }// END first check
//
//
////inline bool FileExists_test( const std::string& name)
////{
////  struct stat buffer;// local variable, whose address is taken to get an output parameter.
////  int result = stat( name.c_str(), &buffer);// NB. buffer contains a lot of interesting fields after the call.
////  bool FileExists = (result==0);
////  return FileExists;
////}
//////bool result = FileExists_test("./LogSinkFsConfig.txt");
//
//
////    // desinenza dinamica per log rotation.
////    time_t now = time(0);// current date/time based on current system
////    char * dynamicEnding = ctime(&now);// convert Operating System date to string form.
////    std::string LogFsName(dynamicEnding);
////    std::string dateStamp(LogFsName.substr(0,11) + LogFsName.substr(20,4) + "_" );
////    std::string timeStamp(LogFsName.substr(11,8) );
////    //
////    std::string traceStamp = dateStamp + timeStamp;
////    std::cout<<"traceStamp = "<<traceStamp<<std::endl;
////    //
//////dayName substr(0,3)
//////month substr(5,3)
//////day substr(8,2)
//////year substr(11,4)
//////    std::string     year = LogFsName.substr(20,4);
//////    std::string     month = LogFsName.substr(20,4)
//////    std::string     day
//////    std::string     hour
//////    std::string     min
//////    std::string     sec
////
////
////    string month = (DateTime.Now.Month  < 10) ? ("0" + DateTime.Now.Month.ToString()  ) : (DateTime.Now.Month.ToString()  );
////    string   day = (DateTime.Now.Day    < 10) ? ("0" + DateTime.Now.Day.ToString()    ) : (DateTime.Now.Day.ToString()    );
////    string hour =  (DateTime.Now.Hour   < 10) ? ("0" + DateTime.Now.Hour.ToString()   ) : (DateTime.Now.Hour.ToString()   );
////    string min  =  (DateTime.Now.Minute < 10) ? ("0" + DateTime.Now.Minute.ToString() ) : (DateTime.Now.Minute.ToString() );
////    string sec  =  (DateTime.Now.Second < 10) ? ("0" + DateTime.Now.Second.ToString() ) : (DateTime.Now.Second.ToString() );
////    string timestamp =
////        DateTime.Now.Year.ToString() +"_"+
////        month +"_"+
////        day +"_"+
////        hour +"_"+
////        min +"_"+
////        sec;
////
//
////                        // current date/time based on current system
////                        time_t now = time(0);
////                        // convert now to string form
////                        char* dynamicEnding = ctime(&now);
////                        printf("\n\tThe local date and time is: %s \n", dynamicEnding);
////                        //std::cout << "The local date and time is: " << dt << endl;
////
////
////                        std::string LogFsName(dynamicEnding);
////                        int * dirtyPositions = new int[LogFsName.length()];
////                        for(int c=0; c<LogFsName.length(); c++)
////                        {
////                            if(32==LogFsName[c])
////                            {
////                                dirtyPositions[c] = 1;// is blank
////                            }
////                            else if(':'==LogFsName[c])
////                            {
////                                dirtyPositions[c] = 2;// is semicolon
////                            }
////                            else if('\n'==LogFsName[c])
////                            {
////                                dirtyPositions[c] = 3;// is new line
////                            }
////                            else
////                            {
////                                dirtyPositions[c] = 0;// is OK.
////                            }
////                        }
////                        for(int c=0; c<LogFsName.length(); c++)
////                        {
////                            if(1==dirtyPositions[c])// is blank
////                            {
////                                LogFsName[c] = '_';
////                            }
////                            else if(2==dirtyPositions[c])// is semicolon
////                            {
////                                LogFsName[c] = '#';
////                            }
////                            else if(3==dirtyPositions[c])// is new line
////                            {
////                                LogFsName[c] = '_';// eliminate the new line.
////                            }// else  is NOT blank : leave it.
////                        }
////                        delete[] dirtyPositions;
////
////                        printf("\n\tThe local date and time is: %s \n", LogFsName.c_str() );
////                        delete[] dynamicEnding;
//
//
////Map_managment();
//
////StringStream_exercise();
//
////TestTSingleonWrapper();
//
////      ---- binary tree -----
////    char * dataFilePath = (char *)calloc( 100, sizeof(char) ) ;
////    sprintf(dataFilePath, "./treeData.txt");
////    int treeRes = BinTree_wrapper_C_( dataFilePath );
////    // on re-entry :
////    free( dataFilePath);
//
//
//void fReader_byString()
//{
//   std::ifstream dumpReader( "./PrimeIntegral_fromOrigin_.txt", std::fstream::in );// read-only.
//   dumpReader.seekg( 0, dumpReader.end);
//   long dumpSize = dumpReader.tellg();
//   dumpReader.seekg( dumpSize/2, dumpReader.beg );
//   int bufSize = 80;
//   char * buf = nullptr;
//   for( ; !dumpReader.eof() && dumpSize>bufSize; )
//   {
//       dumpSize = dumpReader.tellg();
//       bufSize = dumpSize/2;//adaptive.
//       buf = new char[bufSize];
//       dumpReader.read( buf, bufSize-1);
//       buf[bufSize-1]=0;
//       dumpReader.seekg( dumpSize/2, dumpReader.beg );
//       std::cout << buf << std::endl;
//       delete[] buf;
//   }
//   dumpReader.close();
//}// fReader_byString
//
//
//
//void fReader_byRow()
//{
//   std::ifstream dumpReader( "./PrimeIntegral_fromOrigin_.txt", std::fstream::in );// read-only.
//   dumpReader.clear();
//   dumpReader.seekg(0, ios::beg);// from start
//   int bufSize = 20;
//   char buf[bufSize];
//   for( ; !dumpReader.eof(); )
//   {
//       dumpReader.getline( buf, bufSize-1,'\r');
//       buf[bufSize-1]=0;
//       std::cout << buf << std::endl;
//   }
//   dumpReader.close();
//}// fReader_byRow
//
////NB.////dumpReader.clear();
////dumpReader.seekg( bufSize, ios::beg);// from start
//
//
//
//unsigned long factorial( unsigned int par)
//{
//    unsigned long res = +1UL;
//    for( int c=par; c>+1; c--)
//    {
//        res *= c;
//    }
//    return res;
//}// factorial
//
//double factorial( unsigned int par, bool onReals)
//{
//    double res = +1.0;
//    for( int c=par; c>+1; c--)
//    {
//        res *= c;
//    }
//    return res;
//}// factorial
//
//
//// TODO: verificare convergenza, per zone del piano complesso.
//Numerics::Complex ExpIntegralEi_Ramanujan( Numerics::Complex zVariable)
//{/* notes on a convergent series:
//    N[(+EulerGamma + Log[zVariable]) +
//    Exp[zVariable/2]*Sum[((-1)^(n - 1) (zVariable)^n)/((n!)*(2^(n - 1)))*
//    Sum[+1/(2*k + 1), {k, 0, Floor[(n - 1)/2]}], {n, +1, +99}]]
//    */
//    const double EulerGamma = +0.577216;// Euler-Mascheroni.
//    Numerics::Complex externalAddend(0.0, 0.0);// init to zero the Sum element. The external one is never updated.
//    Numerics::Complex internalFactor(+1.0, 0.0);// the internal one is a factor and gets reset at each external-loop.
//    //
//    for( int n=+1; n<=+12; n++)// NB. ######## factorial does not support (now) more than 12! ######
//    {
//        for(int k=0; k< floor(((double)n - 1.0)/2.0); k++ )
//        {
//            internalFactor += +1.0/(2.0*(double)k + 1.0);
//        }// end internal-factor finite sum.
//        externalAddend += (zVariable^n)*pow((-1.0),((double)n - 1.0))  /(factorial(n,true)* pow(2.0,((double)n - 1)) ) * internalFactor;
//        internalFactor = +1.0;// reset.
//    }// end external series step.
//    externalAddend += zVariable.LnC() + EulerGamma;// final addenda.
//    // ready.
//    return externalAddend;
//}// Ramanujan series
//
//
//double fFormExpIntegralE1_Re( double u
// ,double x, double y )// these last ones have to be constant, since they are Re and Im of the complex param.
//{
//    return exp(-x/u)*cos(y/u)/u;
//}
//
//double fFormExpIntegralE1_Im( double u
// ,double x, double y )// these last ones have to be constant, since they are Re and Im of the complex param.
//{
//    return -exp(-x/u)*sin(y/u)/u;
//}
//
//double EunoWrapper_RealPart;
//double EunoWrapper_ImmaginaryPart;
//double EunoWrapper_Re( double u)
//{
//    return fFormExpIntegralE1_Re( u,EunoWrapper_RealPart,EunoWrapper_ImmaginaryPart);
//}//EunoWrapper_Re
//double EunoWrapper_Im( double u)
//{
//    return fFormExpIntegralE1_Im( u,EunoWrapper_RealPart,EunoWrapper_ImmaginaryPart);
//}//EunoWrapper_Im
//
//
//Numerics::Complex EunoZeta( Numerics::Complex zVariable)
//{/*
//ComplexExpand[ Exp[-(x + I*y)/u]/u] ==
//                (\[ExponentialE]^(-(x/u))*Cos[y/u])/u +
//- (\[ImaginaryI] \[ExponentialE]^(-(x/u)) Sin[y/u])/u     ==
//==              (E^(-(x/u))*Cos[y/u])/u +
//- (\[ImaginaryI]*E^(-(x/u))*Sin[y/u])/u      ==
//== (E^(-(x/u))*Cos[y/u])/u - (I*E^(-(x/u))*Sin[y/u])/u ==
//== (E^(-(x/u)))/u*(Cos[y/u]-(I*Sin[y/u]) ==
//== (E^(-(x/u)))/u*(E^(-I*(y/u)))
//    */
//    //
//    EunoWrapper_RealPart = zVariable.Re();
//    EunoWrapper_ImmaginaryPart = zVariable.Im();
//    Entity::Integration::FunctionalForm f_Re = EunoWrapper_Re;// function pointer to wrapper for Real_part.
//    Entity::Integration::FunctionalForm f_Im = EunoWrapper_Im;// function pointer to wrapper for Immaginary_part.
//    // integrate in du , u in (0,+1)
//    double RealPart = Entity::Integration::trapezi( 0.0, +1.0, 999, f_Re);
//    Numerics::Complex res( Entity::Integration::trapezi( 0.03, +1.0, 999, f_Re)
//                              , Entity::Integration::trapezi( 0.03, +1.0, 999, f_Im) );
//    //ready.
//    return res;
//}// EunoZeta
//
//
//    Numerics::Complex zVariable( +33.0, 1952.0 );
//    const double dx = +1.0E-3;
//    for( double u=0.03; u<=+0.97; u+=dx)
//    {
//        double re = fFormExpIntegralE1_Re( u, zVariable.Re(), zVariable.Im() );
//        double im = fFormExpIntegralE1_Im( u, zVariable.Re(), zVariable.Im() );
//        std::cout<<"\n\t fFormExpIntegralE1_xx( "<<u<<", "<< zVariable.Re() <<" +I* "<< zVariable.Im() <<")==" << re <<" +I* "<< im <<std::endl;
//    }
//
//    Numerics::Complex res = EunoZeta( zVariable);
//    std::cout<<"\n\t Euno( "<< zVariable.Re() <<" +I* "<< zVariable.Im() <<")==" << res.Re() <<" +I* "<< res.Im() <<std::endl;

//    Numerics::Complex zVariable( +33.0, 1952.0 );
//    Numerics::Complex res = ExpIntegralEi_Ramanujan( zVariable);
//    std::cout<<"\n\t ExpIntegralEi_Ramanujan( "<< zVariable.Re() <<" +I* "<< zVariable.Im() <<")==" << res.Re() <<" +I* "<< res.Im() <<std::endl;

//    for( int c=0; c<19; c++)
//    {
//        std::cout<<"\n\tFactorial("<<c<<")=="<<factorial(c)<<std::endl;
//        std::cout<<"\n\tFactorial("<<c<<")=="<<factorial(c, true)<<std::endl;
//    }
//
//    struct SingleFactor
//    {
//        unsigned long  pi;
//        unsigned long  ai;
//    };
//
//SingleFactor * protoFactorize( unsigned long par)
//{
//    SingleFactor * factorization = new SingleFactor[100];// TODO #
//    unsigned long sogliaStimata = par/2;// greatest involved-prime is the cofactor of the smallest one(i.e. 2).
//    // ordinaleStimato == LogIntegral[ sogliaStimata] NB. overstimate it, for safety.
////        Entity::Integration::FunctionalForm LogIntegral = LogIntegral_coChain;// function pointer.
////        double LogIntegral_ofInfPar = Entity::Integration::trapezi( +2.0, (double)infLeft, ((double)infLeft-2.0)*4, LogIntegral );
////     unsigned ordinaleStimato = (unsigned long)LogIntegral_ofInfPar;//TODO stima !
//    unsigned ordinaleStimato = 11UL; // TODO
//    for(int c=0; c<ordinaleStimato; c++)
//    {// init.
//        factorization[c].pi = 0;
//        factorization[c].ai = 0;
//    }
//    // TODO readRange( 1, ordinaleStimato);
//    unsigned long * involvedPrimes = new unsigned long[ordinaleStimato]{2,3,5,7,11,13,17,19,23,29,31};
//    unsigned long dividendo, divisore;
//    dividendo = par;
//    double realQuotient;
//    unsigned long intQuotient;
//    int i=0;// start from +2. indice nel vettore dei primi.
//    int acc=0;// indice nel vettore dei risultati.
//    divisore=involvedPrimes[i];
//    bool lastDivisionWasDiophantine =  false;
//    double soglia = (double)dividendo/2.0; // greatest involved-prime is the cofactor of the smallest one(i.e. 2).
//    //
//    for(  ; +1<dividendo; )
//    {
//        realQuotient = (double)dividendo/(double)divisore;
//        intQuotient = dividendo/divisore;
//        if( realQuotient-intQuotient <+1.0E-80 )// ####### ramo lastDivisionWasDiophantine ##
//        {// divisione diofantea : the prime acting as divisor is a factor (i.e. divides dividendo).
//            if(  lastDivisionWasDiophantine)
//            {
//                // factorization[acc].pi is already correct: do nothing.
//                factorization[acc].ai++;// increment ai on this pi
//                lastDivisionWasDiophantine =  true;
//            }
//            else if( ! lastDivisionWasDiophantine)
//            {
//                factorization[acc].pi = divisore;// promote current prime and its exponent.
//                factorization[acc].ai++;// increment ai on this pi
//                lastDivisionWasDiophantine =  true;
//            }// No other else.
//            // in common btw curDivDiophantine
//            dividendo = intQuotient;// NB. swap the dividendo, after a successful
//        }// if // divisione diofantea : the prime acting as divisor is a factor (i.e. divides dividendo).
//        else// ### no Diophantine division ##
//        {// else: goto test next prime, as divisor.
//            if(  lastDivisionWasDiophantine)
//            {
//                acc++;// next factor slot, in the results array.
//            }
//            else if( ! lastDivisionWasDiophantine)
//            {
//                // NO acc++ we don't have an idoneous factor, yet.
//            }// No other else.
//            // factors in common btw lastDivisionWasDiophantine when curDivNOTDiophantine
//            i++;// test next prime, as factor.
//            lastDivisionWasDiophantine =  false;
//            divisore=involvedPrimes[i];// to next prime, if cur one works no more
//        }// else// ### no Diophantine division ##
//    }
//    //..
//    delete[] involvedPrimes;
//    // ready.
//    return factorization;// NB. the caller has to delete.
//}// protoFactorize
