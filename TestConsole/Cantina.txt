
/***********************************************  cantina *****************************************************


    //
    // UnderTest:: NB. local to main::
//    UnderTest::Primes *p = new UnderTest::Primes();
//    bool res = p->SequentialCalcInterface( 5200);
//    bool readRes = p->ReadSequentialDumpInterface();

//    bool res = p->RandomCalcInterface(
//       6000000000
//       ,6000000100 );

//    res = p->SequentialCalcInterface( 11200);
//    const char * stringDumpTail = p->newDeal_dumpTailReaderByChar( p->sequentialDumpPath );
//    //
//    int recordArray_cardinality=0;
//    UnderTest::Primes::DumpElement * recordArray = p->newDeal_recoverDumpTail( stringDumpTail , &recordArray_cardinality );
//    if(nullptr != recordArray)
//    {
//        for(int c=0; c<recordArray_cardinality; c++) // array's cardinality is an out-param.
//        {
//            std::cout<<"\n\t Record "<< recordArray[c].ordinal<<"_"<<recordArray[c].prime;
//        }// for
//    }// else NO recordArray available.
//    //
//    UnderTest::Primes::DumpElement * lastRec = nullptr;
//    long LastOrdinal = 0UL;//lastRec->ordinal; // p->getLastOrdinal();
//    long LastPrime = 0UL;//  lastRec->prime;// p->getLastPrime();
//    if(nullptr!=stringDumpTail)
//    {
//        lastRec = p->newDeal_recoverLastRecord( stringDumpTail);
//        if(nullptr!=lastRec)
//        {
//            LastOrdinal =lastRec->ordinal;
//            LastPrime =lastRec->prime;
//        }// else the string stringDumpTail is invalid -> no record has been recovered.
//    }// else sequentialFile not present.  TODO
//    // p->recoverLastRecord( p->theDumpTailStr);
//    // UnderTest::Primes::DumpElement * lastRecord = p->recoverDumpTail( nullptr );// ???
//    // delete[] lastRecord;
//    //
//    res = p->RandomCalcInterface(
//       999900
//       ,999999 );



//    res = p->SequentialCalcInterface( 200);
//    LastOrdinal = p->getLastOrdinal();
//    LastPrime = p->getLastPrime();

//    res = p->SequentialCalcInterface(  50);
//    res = p->SequentialCalcInterface( 100);
//    //
//    long desPrime = (*p)[25];
//    std::string logMsg = "desPrime = (*p)[25]==";
//    std::string * desinenza = Common::StrManipul::uLongToString( desPrime);
//    logMsg += *desinenza;
//    Common::LogWrappers::SectionContent( logMsg.c_str(), 0 );
//    delete desinenza;
//    //
//    desPrime = (*p)[3];
//    logMsg = "desPrime = (*p)[3]==";
//    desinenza = Common::StrManipul::uLongToString( desPrime);
//    logMsg += *desinenza;
//    Common::LogWrappers::SectionContent( logMsg.c_str(), 0 );
//    delete desinenza;
//    delete p;
    //-----



//const std::string customFileConfigSectionName( "primeCustomFile");
//    tryReadForewards();
//    tryReadBackwards();
    // system("pwd");
    // system("dir"); Process_cur_dir: Directory di C:\root\projects\GitHubSandBox\PostMRW\TestConsole

// empty Ctor : reads both the sequentialFile and randomFile fullpath
Cantiere_Primes_2022September01_::Primes::Primes( )
{
    bool dumpPathAcquisitionFromConfig = false;// init to invalid
    //
    this->feedDumpPath();// SEQUENTIAL : default section, in default file.
    if( nullptr != this->sequentialDumpPath )
    {
        this->createOrAppend( this->sequentialDumpPath);
        //this->dumpTailReaderByChar( this->sequentialDumpPath);//-----indiziato
        const char * lastRecString = this->lastRecordReaderByChar(  this->sequentialDumpPath);
        if( nullptr != this->theDumpTailStr)
        {
            recoverLastRecord( this->theDumpTailStr);// members should be in place, now: lastOrdinal, lastPrime.
        }// else : no valid last record : start from zero!
        // the upper bound for research, in R+, will be a parameter for the sequentialCalcInterface()
        dumpPathAcquisitionFromConfig = true;// from the init=false this is the first reset. Subsequent ones will be &=
    } // else dumpPathAcquisitionFromConfig already false from init.
    //----end of SequentialPath --- start of RandomPath -------
    this->feed_CustomDumpPath();// CUSTOM section, in default file.
    if( nullptr != this->randomDumpPath )
    {
        this->createOrAppend( this->randomDumpPath);
        dumpPathAcquisitionFromConfig &= true;// NB &= only if both files are found, the flag gets true.
    }// else :  not-healthly built:  dumpPathAcquisitionFromConfig already false from init.
    //---check operations' result and document the error for the user.
    if( false==dumpPathAcquisitionFromConfig)// something wrong reading from config files.
    {// not-healthly built.
        this->isHealthlyConstructed = false;
        this->canOperate = false;
    }// not-healthly built.
}// empty Ctor : reads both the sequentialFile and randomFile fullpath


bool Cantiere_Primes_2022September01_::Primes::SequentialCalcInterface( unsigned long Threshold )
{
    bool dumpPathAcquisitionFromConfig = false;// init to invalid
    if( nullptr != this->sequentialDumpPath )
    {
        this->createOrAppend( this->sequentialDumpPath);
        this->dumpTailReaderByChar( this->sequentialDumpPath);
        if( nullptr != this->theDumpTailStr)
        {
            recoverLastRecord( this->theDumpTailStr);// members should be in place, now: lastOrdinal, lastPrime.
        }// else : no valid last record : start from zero!
        // the upper bound for research, in R+, will be a parameter for the sequentialCalcInterface()
        dumpPathAcquisitionFromConfig = true;// from the init=false this is the first reset. Subsequent ones will be &=
    } // else dumpPathAcquisitionFromConfig already false from init.
    //
    this->append_Sequential_Stream = new std::ofstream( this->sequentialDumpPath, std::fstream::out | std::fstream::app);
    // ---call with params
    this->Start_PrimeDump_FileSys( this->getLastPrime() , Threshold , append_Sequential_Stream );
    this->append_Sequential_Stream->close();
    delete this->append_Sequential_Stream;
    this->append_Sequential_Stream = nullptr;
    //
    return dumpPathAcquisitionFromConfig;
}


bool Cantiere_Primes_2022September01_::Primes::RandomCalcInterface( unsigned long infLeft, unsigned long maxRight )
{
    bool res = false;
    //
    // NB. no {dumpTailReader, recoverLastRecord,...} -> work in [infLeft, maxRight].
    Entity::Integration::FunctionalForm LogIntegral = internalAlgos::LogIntegral_coChain;// function pointer.
    double LogIntegral_ofInfPar = Entity::Integration::trapezi( +2.0, (double)infLeft, ((double)infLeft-2.0)*4, LogIntegral );
    this->lastOrdinal= (unsigned long)LogIntegral_ofInfPar;//TODO stima !
    this->lastPrime = infLeft;//##### the first integer analyzed will be infLeft+1; the last will be "maxRight" parameter.##
    this->desiredThreshold = maxRight;
    // write a stamp, about what we're doing and when.
    time_t ttime = time(0);
    char* dt = ctime(&ttime);
    //   NB. for UTC Greenwich tm *gmt_time = gmtime(&ttime);
    //   NB. for UTC Greenwich dt = asctime(gmt_time);
    //
    this->append_Random_Stream = new std::ofstream( this->randomDumpPath , std::fstream::out | std::fstream::app);
    *(this->append_Random_Stream) << "\n\n Custom Interval ("<<infLeft<<", "<<maxRight<<"] ,worked on: "<<dt; //test<<"\n";
    *(this->append_Random_Stream) << " Ordinals are extimated by LogIntegral; so the ordinal appears usually bigger than the correct one.\n";
    // ---call with params
    Start_PrimeDump_FileSys( infLeft, maxRight, this->append_Random_Stream );
    //
    this->append_Random_Stream->close();
    delete this->append_Random_Stream;
    this->append_Random_Stream = nullptr;
    return res;
}





const char * Cantiere_Primes_2022September01_::Primes::feedDumpPath() // non const
{// default section, in default file.
    if( nullptr==this->sequentialDumpPath )
    {
        this->sequentialDumpPath = this->getPrimeDumpFullPath( "primeDefaultFile");// Default Section Name.
    }//else ready.
    return this->sequentialDumpPath;
}// feedDumpPath()

const char * Cantiere_Primes_2022September01_::Primes::feed_CustomDumpPath() // non const
{// custom section, in default file.
    if( nullptr==this->randomDumpPath )
    {
        this->randomDumpPath = this->getPrimeDumpFullPath( "primeCustomFile");// CUSTOM Section Name, for non complete dumping.
    }//else ready.
    return this->randomDumpPath;
}// feed_CustomDumpPath()

const char * Cantiere_Primes_2022September01_::Primes::getPrimeDumpFullPath( const std::string & sectionNameInFile) const
{
    const char *  res = nullptr;
    Common::ConfigurationService * primeNamedConfig = new Common::ConfigurationService( "./PrimeConfig.txt");// default Prime-configuration-file. All configurations for Primes:: in this file.
    const std::string * desiredSectionContent = primeNamedConfig->getValue( sectionNameInFile);// configSectionNames can be added.
    res = desiredSectionContent->c_str();
    delete primeNamedConfig;
//delete desiredSectionContent;  TODO study how to delete it.
    return res;// caller has to delete.
}// getPrimeDumpFullPath





    /// Dtor()
    Cantiere_Primes_2022September01_::Primes::~Primes()
    {/// Dtor() : closes the append_handle.
        if( nullptr != this->sequentialDumpPath )
        {
            delete[] this->sequentialDumpPath;
            this->sequentialDumpPath = nullptr;
        }
        if( nullptr != this->randomDumpPath )
        {
            delete[] this->randomDumpPath;
            this->randomDumpPath = nullptr;
        }
//        if( nullptr != this->theDumpTailStr ) TODO buggy : let it local and delete after usage
//        {
//            delete[] this->theDumpTailStr;
//            this->theDumpTailStr = nullptr;
//        }
        if( nullptr != this->dumpTail )
        {
            delete[] this->dumpTail;
            this->dumpTail = nullptr;
        }

//        if( nullptr != this->appendStream)  no more a global class::variable.
//        {
//            this->appendStream->close();
//            this->appendStream = nullptr;
//        }// else already closed.
//
    }// Dtor(





bool Cantiere_Primes_2022September01_::Primes::getLastCoupleInDefaultFile()
{
    bool res = false;// init to invalid.
    this->feedDumpPath();
    if( nullptr != this->sequentialDumpPath )
    {
        this->createOrAppend( this->sequentialDumpPath);
    }// else : TODO not-healthly built.
    else {return res;}// which is still "false".
    this->dumpTailReaderByChar( this->sequentialDumpPath);
    if( nullptr != this->theDumpTailStr)
    {
        recoverLastRecord( this->theDumpTailStr);// members should be in place, now: lastOrdinal, lastPrime.
    }// else : no valid last record : start from zero!
    else {return res;}// which is still "false".
    // ready:
    res = true;// all ok.
    return res;
}// getLastCoupleInDefaultFile







void Cantiere_Primes_2022September01_::Primes::createOrAppend( const std::string & fullPath)
{
    ofstream createOrApp(fullPath, std::fstream::out | std::fstream::app);
    createOrApp.close();
}// dumpFile createOrAppend



//   no more used
//const char * Cantiere_Primes_2022September01_::Primes::dumpTailReader( const std::string & fullPath)
//{
//    if(nullptr!=this->theDumpTailStr)
//    {
//        return this->theDumpTailStr;
//    }// else build it.
//    ifstream lastrecReader(fullPath, std::fstream::in );
//    lastrecReader.seekg( 0, lastrecReader.end);
//    int streamSize = lastrecReader.tellg();
//    int lastTokenHypothesizedLength;// f(streamSize).
//    // cannot use runtime-expressions in switch-case: case-labels have to be compile-time constants.
//    if( streamSize<4)
//        {// no valid last-record in place.
//            this->lastOrdinal=0UL;
//            this->lastPrime=+1UL;//##### +2 first of the Primes p in P in N. this->lastPrime gets a ++ before start.
//            return nullptr;// NB ##### do NOT call recoverLastRecord on a null ptr !!! ####################
//        }
//    else if( streamSize>=4 && streamSize<=10)
//        {
//            lastTokenHypothesizedLength = streamSize;
//        }
//    else if( streamSize>10 && streamSize<=200)
//        {
//            lastTokenHypothesizedLength = 10;
//        }
//    else// i.e. case >200
//        {
//            lastTokenHypothesizedLength = this->tailRecordSize;// 60 is suitable for primes in magnitude-order of 10^9.
//        }// end of if( streamsize..)->seek( howMuch, end).
//    //
//    int multeplicity = 5;// less two times backwards, from EOF.
//    lastrecReader.seekg( -1*multeplicity*lastTokenHypothesizedLength, lastrecReader.end);// seek(-size,end)=:goBack(size,fromEOF).
//    this->theDumpTailStr = new char[multeplicity*lastTokenHypothesizedLength+1];// TODO test
//    lastrecReader.read( this->theDumpTailStr, multeplicity*lastTokenHypothesizedLength);// fill this->theDumpTailStr from the stream-tail.
//    this->theDumpTailStr[multeplicity*lastTokenHypothesizedLength]=0;//terminate.
//    lastrecReader.close();
//    // ready.
//    return this->theDumpTailStr;
//}// dumpTailReader


//
const char * Cantiere_Primes_2022September01_::Primes::lastRecordReaderByChar( const std::string & fullPath)
{
    ifstream lastrecReader(fullPath, std::fstream::in );
    lastrecReader.seekg( 0, lastrecReader.end);
    int streamSize = lastrecReader.tellg();
    Common::StringBuilder * sb = new Common::StringBuilder( 100);// forecasted size.
    lastrecReader.seekg( -1, lastrecReader.end);// get in place to read last char.
    int currentPosition;
    int step = 0;
    int howManyLineEndings = 0;
    for( char c=0; ! lastrecReader.eof(); )
    {
        lastrecReader.get( c);
        sb->append(c);
        step++;
        currentPosition = lastrecReader.tellg();
        lastrecReader.seekg( -1*step , lastrecReader.end);
        if( 10==c || 13==c)
            {howManyLineEndings++;}
        if(2==howManyLineEndings)
            {break;}
    }// for
    std::string bufferedReverseTail = sb->str();
    int bufferedReverseTail_len = bufferedReverseTail.length();
    const char * reverseTailDump = sb->str().c_str();
    char * directTailDump = new char[step+1];
    for(int c=0; c<step; c++)
    {
        directTailDump[c] = reverseTailDump[step-c];
    }
    delete sb;
    // ready
    return directTailDump;// caller has to delete
}// lastRecordReaderByChar


const char * Cantiere_Primes_2022September01_::Primes::dumpTailReaderByChar( const std::string & fullPath)
{
    if(nullptr!=this->theDumpTailStr)
    {
        return this->theDumpTailStr;
    }// else build it.
    ifstream lastrecReader(fullPath, std::fstream::in );
    lastrecReader.seekg( 0, lastrecReader.end);
    int streamSize = lastrecReader.tellg();
    int lastTokenHypothesizedLength;// f(streamSize).
    // cannot use runtime-expressions in switch-case: case-labels have to be compile-time constants.
    if( streamSize<4)
        {// no valid last-record in place.
            this->lastOrdinal=0UL;
            this->lastPrime=+1UL;//##### +2 first of the Primes p in P in N. this->lastPrime gets a ++ before start.
            return nullptr;// NB ##### do NOT call recoverLastRecord on a null ptr !!! ####################
        }
    else if( streamSize>=4 && streamSize<=10)
        {
            lastTokenHypothesizedLength = streamSize;
        }
    else if( streamSize>10 && streamSize<=200)
        {
            lastTokenHypothesizedLength = 10;
        }
    else// i.e. case >200
        {
            lastTokenHypothesizedLength = this->tailRecordSize;// 60 is suitable for primes in magnitude-order of 10^9.
        }// end of if( streamsize..)->seek( howMuch, end).
    //
    int multeplicity = 5;// less "multeplicity" times backwards, from EOF.
// avoid it:lastrecReader.seekg( -1*multeplicity*lastTokenHypothesizedLength, lastrecReader.end);// seek(-size,end)=:goBack(size,fromEOF).
    lastrecReader.seekg( streamSize-multeplicity*lastTokenHypothesizedLength, lastrecReader.beg );
//this->theDumpTailStr = new char[multeplicity*lastTokenHypothesizedLength+1];// TODO test
//Substituted lastrecReader.read( this->theDumpTailStr, multeplicity*lastTokenHypothesizedLength);// fill this->theDumpTailStr from the stream-tail.
    Common::StringBuilder * sb = new Common::StringBuilder(multeplicity*lastTokenHypothesizedLength+1);// forecasted size.
    for( char c=0; lastrecReader.get(c); )
    {
        sb->append(c);
    }
    this->theDumpTailStr = (char *)(sb->str().c_str());// caller has to delete!
    lastrecReader.close();
    // ready.
    return this->theDumpTailStr;
}//dumpTailReaderByChar()


unsigned long Cantiere_Primes_2022September01_::Primes::getLastOrdinal()
{
    this->feedDumpPath();// default section, in default file.
    if( nullptr == this->sequentialDumpPath)
    {
        this->isHealthlyConstructed = false;
        this->canOperate = false;
        throw;
    }// else :  healthly built: continue:
    this->dumpTailReaderByChar( this->sequentialDumpPath);
    if( nullptr != this->theDumpTailStr)
    {
        recoverLastRecord( this->theDumpTailStr);// members should be in place, now: lastOrdinal, lastPrime.
    }// else : no valid last record : start from zero!
    else
    {
        this->lastOrdinal = 0;
        this->lastPrime = 0;
    }
    return this->lastOrdinal;
}//getLastOrdinal

unsigned long Cantiere_Primes_2022September01_::Primes::getLastPrime()
{// default section, in default file.
    this->feedDumpPath();
    if( nullptr == this->sequentialDumpPath)
    {
        this->isHealthlyConstructed = false;
        this->canOperate = false;
        throw;
    }// else :  healthly built: continue:
    this->dumpTailReaderByChar( this->sequentialDumpPath);
    if( nullptr != this->theDumpTailStr)
    {
        recoverLastRecord( this->theDumpTailStr);// members should be in place, now: lastOrdinal, lastPrime.
    }// else : no valid last record : start from zero!
    else
    {
        this->lastOrdinal = 0;
        this->lastPrime = 0;
    }
    return this->lastPrime;
}//getLastPrime



 unsigned strlen_loc( char * par)
 {
     int res = 0;
     if(nullptr==par) {return res;}
     for( ; par[res]!=0; res++);
     return res;
 }




  IntegerDecomposition : the Fundamental Thm of Arithmetic.
Cantiere_Primes_2022September01_::Primes::SingleFactor * Cantiere_Primes_2022September01_::Primes::IntegerDecomposition( const unsigned long dividend)
{
    Entity::Integration::FunctionalForm LogIntegral = internalAlgos::LogIntegral_coChain;// function pointer.
    double LogIntegral_ofInfPar = Entity::Integration::trapezi( +2.0, (double)dividend, ((double)dividend-2.0)*4, LogIntegral );
    unsigned long ordinaleStimato = (unsigned long)LogIntegral_ofInfPar;// approx eccesso: LogIntegral[Soglia]==LastOrdinal_under_Soglia==Cardinalita[sottoSoglia].
    SingleFactor * factorization = new SingleFactor[ordinaleStimato];// stimare #fattoriMaximal.
    // Oss. greatest involved-prime==dividend/2 in a composite, since greatestFactor is the cofactor of the PotentialSmallest(i.e. 2).
    for(int c=0; c<ordinaleStimato; c++)
    {// init to zeroContentMemory.
        factorization[c].factorBase = 0;
        factorization[c].factorMultiplicity = 0;
    }
    // TODO readRange( 1, ordinaleStimato);
    unsigned long * involvedPrimes = new unsigned long[ordinaleStimato];
    for(int c=0; c<ordinaleStimato; c++)
    {
        involvedPrimes[c] = (*this)[c+1];//NB. Prime[1]==2 , Prime[0]==error.
    }// end filling up the candidate prime-factor array.
    unsigned long dividendo, divisore;
    dividendo = dividend;
    double realQuotient;
    unsigned long intQuotient;
    int i=0;// start from +2. indice nel vettore dei primi.
    int acc=0;// indice nel vettore dei risultati.
    divisore=involvedPrimes[i];
    bool lastDivisionWasDiophantine =  false;
    // #### start factorization loop ######################################################################################
    for(  ; +1<dividendo; )
    {// dividendo will be substituted by Quotient, until dividendo==+1.
        realQuotient = (double)dividendo/(double)divisore;
        intQuotient = dividendo/divisore;
        if( realQuotient-intQuotient <+1.0E-80 )// ####### ramo lastDivisionWasDiophantine ##
        {// divisione diofantea : the prime acting as divisor is a factor (i.e. divides dividendo).
            if(  lastDivisionWasDiophantine)
            {//NB. factorization[acc].pi is already correct: do nothing on current factor "pi"
            }//if(  lastDivisionWasDiophantine)
            else if( ! lastDivisionWasDiophantine)
            {// a new divisor gets promoted.
                factorization[acc].factorBase = divisore;// promote current prime and its exponent.
            }// No other else.
            // NB. Actions in common btw curDivDiophantine:
            factorization[acc].factorMultiplicity++;// increment the exponent of this factor: i.e. pi^ai
            lastDivisionWasDiophantine =  true;// that's something we need to track.
            dividendo = intQuotient;// NB. swap the dividendo, after a successful Diophantine-ratio.
        }// if // divisione diofantea : the prime acting as divisor is a factor (i.e. divides dividendo).
        else// ### no Diophantine division ##
        {// ### no Diophantine division ##
            if(  lastDivisionWasDiophantine)
            {// use next divisor slot, in the results array.
                acc++;// next factor slot, in the results array.
            }
            else if( ! lastDivisionWasDiophantine)
            {// NO acc++ we don't have an idoneous factor, yet.
            }// No other else.
            // NB. Actions in common btw lastDivisionWasDiophantine when curDivNOTDiophantine
            i++;// test next prime, as factor.
            lastDivisionWasDiophantine =  false;
            divisore=involvedPrimes[i];// NB. to next prime, if cur one works no more
        }// else// ### no Diophantine division ##
    }// #### start factorization loop ######################################################################################
    //..
    delete[] involvedPrimes;// no more use of them.
    // NB. swap the prudentially oversized array, in a fit-size one.
    SingleFactor * factorization_srk_ = new SingleFactor[acc+2];// the #divisors, counting from zero + a termination_record, zero filled.
    for(int c=0; c<acc+2; c++)
    {
        factorization_srk_[c] = factorization[c];
    }
    if( factorization[acc+1].factorBase != 0) {throw;}// check on the nullity of last record. It's a placeholder.
    delete[] factorization;// NB. delete the prudentially oversized array, after copying it, in a fit-size one.
    // ready.
    return factorization_srk_;// NB. the caller has to delete.
}// IntegerDecomposition : the Fundamental Thm of Arithmetic.


void  Cantiere_Primes_2022September01_::Primes::recoverLastRecord( const char * dumpTail)
{
    std::string parFromFile(dumpTail);
    int inputParamLength = parFromFile.length();
    std::string filteredLastToken("");
    for( int c=0; c<inputParamLength;c++)
    {
        if( parFromFile[c]>=48 && parFromFile[c]<=57 )// is digit
        {
            filteredLastToken.append( 1, parFromFile[c] );
        }
        else// not digit
        {
            filteredLastToken.append( 1, '_' );// subst. with '_'
        }
    }//for: preserve only digits and substitute everything else with underscore. Then split on underscore.
    std::vector<std::string> * tokenArray = Common::StrManipul::stringSplit("_", filteredLastToken.c_str(), true );// remove empty entries.
    int i=+1;
    for( std::vector<std::string>::reverse_iterator it=tokenArray->rbegin(); it!=tokenArray->rend(); ++it, i++)
    {// preserve only the last two semi-records: they are lastOrdinal and LastPrime.
        if( 1==i)
        {// last Prime
            this->lastPrime = Common::StrManipul::stringToUnsignedLong(*it);
        }
        else if( 2==i)
        {// last ordinal
            this->lastOrdinal = Common::StrManipul::stringToUnsignedLong(*it);
        }// else the token is not interesting; it was included in the read portion, but is not part of the last row.
    }// the two interesting semi-tokens are the last two; so the reading is in reverse order.
}//recoverLastRecord


// produce an array of couples {ordinal,prime} from the dumpTail.
Cantiere_Primes_2022September01_::Primes::DumpElement * Cantiere_Primes_2022September01_::Primes::recoverDumpTail( const char * dumpTail)
{
    if( nullptr != this->dumpTail)
    {// do not build again.
        return this->dumpTail;
    }// else build it; it will be a shared dataMember and Dtor will delete.
    std::string parFromFile(dumpTail);
    int inputParamLength = parFromFile.length();
    std::string filteredLastToken("");
    for( int c=0; c<inputParamLength;c++)
    {
        if( parFromFile[c]>=48 && parFromFile[c]<=57 )// is digit
        {
            filteredLastToken.append( 1, parFromFile[c] );
        }
        else// not digit
        {
            filteredLastToken.append( 1, '_' );// subst. with '_'
        }
    }//for: preserve only digits and substitute everything else with underscore. Then split on underscore.
    std::vector<std::string> * tokenArray = Common::StrManipul::stringSplit("_", filteredLastToken.c_str(), true );// remove empty entries.
    int entryCardinality = tokenArray->size();
// already init this->actualCoupleCardinality = 0;//NB: tagliare al massimo dei minoranti pari
    // NB: stabilire se pari
    if( (double)entryCardinality/2.0 - entryCardinality/2 <+1E-80 )
    {// parita'
        this->actualCoupleCardinality = entryCardinality/2;
    }
    else
    {// DISparita'
        this->actualCoupleCardinality = (entryCardinality-1)/2;// NB: tagliare al massimo dei minoranti pari
    }
    // NB: allocare per tale misura
    this->dumpTail = new DumpElement[actualCoupleCardinality];// member struct-array {ordinal,prime}.
    // NB: fill-up reverse
    int currentCouple=actualCoupleCardinality-1;
    for( std::vector<std::string>::reverse_iterator it=tokenArray->rbegin();
     it!=tokenArray->rend() && currentCouple>=0;
       currentCouple--) // no more increment on the iterator
    {// preserve the last complete-records: they have to be {Ordinal,Prime}. Use index-parity for this task:
        // get a Prime from tailEnd, coming back:
        this->dumpTail[currentCouple].prime =  Common::StrManipul::stringToUnsignedLong(*(it++));
        // get an ordinal from tailEnd, coming back:
        this->dumpTail[currentCouple].ordinal =  Common::StrManipul::stringToUnsignedLong(*(it++));// goto next record backwards.
    }// the interesting semi-tokens are the ones of complete records; so the reading is in reverse order, excluding a partial record, if present.
    delete tokenArray;
    //ready.
    return this->dumpTail;// caller has to delete.
}//recoverDumpTail


    // state of the art.
void Cantiere_Primes_2022September01_::Primes::Start_PrimeDump_FileSys(
                                                                        unsigned long Left
                                                                        ,unsigned long Right
                                                                        ,std::ofstream * appendStream
                                                                    )
{
    unsigned long ordinal = this->lastOrdinal;// next Prime to be found, will increase the ordinal.TODO: decide whether to increment the member.
    bool isStillPrime = true;
    double realQuotient;
    unsigned long intQuotient;
    unsigned long cursor = this->lastPrime+1UL;// start stepping from the Int after the last found Prime.
    if( cursor<+2){cursor=+2;}// 1 (i.e. one) is the product-invariant; so, not a prime.
    // NB now a data-member ; ofstream appendStream( this->sequentialDumpPath, std::fstream::out | std::fstream::app);
    //
    for( ; cursor<=Right; cursor++)//NB. cursor==dividend.
    {
        double soglia = sqrt( cursor);// division is a two-operand operator: the bisection of dividend is Sqrt[dividend]
        // when dividend/Sqrt[dividend]==Sqrt[dividend] and when dividend/(Sqrt[dividend]+eps)<Sqrt[dividend]
        // so the stepping into divisor>Sqrt[dividend] leads to divisors<Sqrt[dividend] which have already been explored.
        unsigned long divisor=+2;
        for( ; divisor<=soglia; divisor++)
        {
            realQuotient = (double)cursor/(double)divisor;
            intQuotient = cursor/divisor;
            if( realQuotient-intQuotient <+1.0E-80 )
            {// divisione diofantea
                isStillPrime = false;// NB. #################
                break;// NB. #################
            }// else  continue searching for primality.
        }// the internal for : the one from [+2, cursor]
        // if after all idoneous divisors..
        if( isStillPrime)
        {
            ++ordinal;//another one foud, starting from zero, so that Prime[1]=2
            std::string * ordinalStr = Common::StrManipul::uLongToString(ordinal);
            std::string * primeStr = Common::StrManipul::uLongToString( cursor );
            int forecastedTokenSize = ordinalStr->length()+primeStr->length()+3;//3 stands for '_'+'\n'+'\r'
            Common::StringBuilder * strBuild = new Common::StringBuilder( forecastedTokenSize);
            strBuild->append(ordinalStr->c_str());
            strBuild->append("_");
            strBuild->append(primeStr->c_str());
            strBuild->append("\r");// choose one btw '\r' or '\n'
            delete ordinalStr;
            delete primeStr;
            // instead of returning it, dump it on the file.
            appendStream->write( strBuild->str().c_str(), strBuild->str().length() );
            delete strBuild;// clean up the token-buffer.
            strBuild = nullptr;
        }// else ripristino del flag-primalita' per il candidato divisore successivo.
        else
        {// ripristino della primalita', dopo un composto(i.e. non primo).
            isStillPrime = true;
        }// ripristino della primalita', dopo un composto(i.e. non primo).
    }// external for : the one where cursor cicles from inf to sup, on dividends.
// NO MORE : interface does it : appendStream.close();
    // ready.
}// newDeal IntegralFileFromStartFSproducer

-- end cantina 2022.09.16

// state of the art.
void Cantiere_Primes_2022September01_::Primes::Start_PrimeDump_FileSys() const
{
    unsigned long ordinal = this->lastOrdinal;// next Prime to be found, will increase the ordinal.TODO: decide whether to increment the member.
    bool isStillPrime = true;
    double realQuotient;
    unsigned long intQuotient;
    unsigned long cursor = this->lastPrime+1UL;// start stepping from the Int after the last found Prime.
    ofstream appendStream( this->sequentialDumpPath, std::fstream::out | std::fstream::app);
    //
    for( ; cursor<=this->desiredThreshold; cursor++)//NB. cursor==dividend.
    {
        double soglia = sqrt( cursor);// division is a two-operand operator: the bisection of dividend is Sqrt[dividend]
        // when dividend/Sqrt[dividend]==Sqrt[dividend] and when dividend/(Sqrt[dividend]+eps)<Sqrt[dividend]
        // so the stepping into divisor>Sqrt[dividend] leads to divisors<Sqrt[dividend] which have already been explored.
        unsigned long divisor=+2;
        for( ; divisor<=soglia; divisor++)
        {
            realQuotient = (double)cursor/(double)divisor;
            intQuotient = cursor/divisor;
            if( realQuotient-intQuotient <+1.0E-80 )
            {// divisione diofantea
                isStillPrime = false;// NB. #################
                break;// NB. #################
            }// else  continue searching for primality.
        }// the internal for : the one from [+2, cursor]
        // if after all idoneous divisors..
        if( isStillPrime)
        {
            ++ordinal;//another one foud, starting from zero, so that Prime[1]=2
            std::string * ordinalStr = Common::StrManipul::uLongToString(ordinal);
            std::string * primeStr = Common::StrManipul::uLongToString( cursor );
            int forecastedTokenSize = ordinalStr->length()+primeStr->length()+3;//3 stands for '_'+'\n'+'\r'
            Common::StringBuilder * strBuild = new Common::StringBuilder( forecastedTokenSize);
            strBuild->append(ordinalStr->c_str());
            strBuild->append("_");
            strBuild->append(primeStr->c_str());
            strBuild->append("\r");// choose one btw '\r' or '\n'
            delete ordinalStr;
            delete primeStr;
            // instead of returning it, dump it on the file.
            appendStream.write( strBuild->str().c_str(), strBuild->str().length() );
            delete strBuild;// clean up the token-buffer.
            strBuild = nullptr;
        }// else ripristino del flag-primalita' per il candidato divisore successivo.
        else
        {// ripristino della primalita', dopo un composto(i.e. non primo).
            isStillPrime = true;
        }// ripristino della primalita', dopo un composto(i.e. non primo).
    }// external for : the one where cursor cicles from inf to sup, on dividends.
    appendStream.close();
    // ready.
}// IntegralFileFromStartFSproducer


    this Construction path is devoted to log the results on the default IntegralFile; the one that starts from origin(i.e. +2).
    Another Ctor will be provided, to log on a partial-File, which consists in a custom analysis, in [min, max]. For such
    Ctor the params will be Ctor( min, max, desiredConfigSectionName)
    Cantiere_Primes_2022September01_::Primes::Primes(unsigned long threshold)
    {// default section, in default file.
        this->feedDumpPath();
        if( nullptr != this->sequentialDumpPath)
        {
            this->createOrAppend( this->sequentialDumpPath);
            this->dumpTailReaderByChar( this->sequentialDumpPath);
            if( nullptr != this->theDumpTailStr)
            {
                recoverLastRecord( this->theDumpTailStr);// members should be in place, now: lastOrdinal, lastPrime.
            }// else : no valid last record : start from zero!
            this->desiredThreshold = threshold;// set the upper bound for research, in R+.
        }
        else// else : not-healthly built.
        {// else : not-healthly built.
            this->isHealthlyConstructed = false;
            this->canOperate = false;
        }// else : not-healthly built.
    }// Ctor


    This Construction path is devoted to log the results on a CUSTOM IntegralFile.
    This Ctor is devoted to log on a partial-File, which consists in a custom analysis, in (infLeft, maxRight]. For such
    Ctor the params are: Ctor( infLeft, maxRight, desiredConfigSectionName).
    Cantiere_Primes_2022September01_::Primes::Primes(unsigned long infLeft, unsigned long maxRight, const std::string& desiredConfigSectionName)
    {// CUSTOM section, in default file.
        this->feed_CustomDumpPath();
        if( nullptr != this->customDumpPath)
        {
            this->createOrAppend( this->customDumpPath);
            // NB. no {dumpTailReader, recoverLastRecord,...} -> work in [infLeft, maxRight].
            Entity::Integration::FunctionalForm LogIntegral = internalAlgos::LogIntegral_coChain;// function pointer.
            double LogIntegral_ofInfPar = Entity::Integration::trapezi( +2.0, (double)infLeft, ((double)infLeft-2.0)*4, LogIntegral );
            this->lastOrdinal= (unsigned long)LogIntegral_ofInfPar;//TODO stima !
            this->lastPrime = infLeft;//##### the first integer analyzed will be infLeft+1; the last will be "maxRight" parameter.##
            this->desiredThreshold = maxRight;
            // write a stamp, about what we're doing and when.
            time_t ttime = time(0);
            char* dt = ctime(&ttime);
            //tm *gmt_time = gmtime(&ttime);  NB. for UTC Greenwich
            //dt = asctime(gmt_time);
            ofstream stampWriter( this->customDumpPath, std::fstream::out | std::fstream::app);
            stampWriter<<"\n\n Custom Interval ("<<infLeft<<", "<<maxRight<<"] ,worked on: "<<dt<<"\n";
            stampWriter.close();
        }// else :  not-healthly built.
        else// else : not-healthly built.
        {// else : not-healthly built.
            this->isHealthlyConstructed = false;
            this->canOperate = false;
        }// else : not-healthly built.
    }// Ctor


namespace internalAlgos
{



    // an internal helper, which is the coChain of LogIntegral. Used for ordinal estimates.
    double LogIntegral_coChain( double x)
    {// an internal helper, which is the coChain of LogIntegral. Used for ordinal estimates.
        return +1.0/log(x);
    }// LogIntegral_coChain


unsigned long factorial( unsigned int par)
{
    unsigned long res = +1UL;
    for( int c=par; c>+1; c--)
    {
        res *= c;
    }
    return res;
}// factorial


// TODO:
    void ExpIntegralEi_Ramanujan( double x)//( Complex x)
    {// notes on a convergent series
//
//        N[(+EulerGamma + Log[x]) +
//          Exp[x/2]*Sum[((-1)^(n - 1) (+x)^n)/((n!)*(2^(n - 1)))*
//             Sum[+1/(2*k + 1), {k, 0, Floor[(n - 1)/2]}], {n, +1, +99}]]
//
//
//        N[(+EulerGamma + Log[x]) +
//          Exp[x/2]*Sum[((-1)^(n - 1) (+x)^n)/((n!)*(2^(n - 1)))*
//             Sum[+1/(2*k + 1), {k, 0, Floor[(n - 1)/2]}], {n, +1, +99}]]
//

//        double internalFactor = 0.0;
//        double externalFactor = 0.0;
//        for( int n=+1; n<=+99; n++)
//        {
//            for(int k=0; k<floor(((double)n - 1.0)/2.0); k++)
//            {
//                internalFactor += +1.0/(2.0*(double)k + 1.0);
//            }
//            externalFactor += ((-1.0)^((double)n - 1.0) (+x)^(double)n)/((n!)*(2.0^(n - 1))) * internal_factor;
//            internalFactor = 0.0;// reset.
//        }
//        externalFactor += EulerGamma + Log[x];

        const double EulerGamma = +0.577216;
        double internalFactor = 0.0;
        double externalFactor = 0.0;
        for( int n=+1; n<=+99; n++)
        {
            for(int k=0; k< floor(((double)n - 1.0)/2.0); k++ )
            {
                internalFactor += +1.0/(2.0*(double)k + 1.0);
            }

            externalFactor += pow((-1.0),((double)n - 1.0)) * pow(+x,(double)n) /(factorial(n)* pow(2.0,((double)n - 1)) ) * internalFactor;
            internalFactor = 0.0;// reset.
        }
        externalFactor += EulerGamma + log(x);

  }// Ramanujan series


}// end nmsp internalAlgos


unsigned long Cantiere_Primes_2022September01_::Primes::getActualLength()
{
    this->feedDumpPath();
    if( nullptr == this->sequentialDumpPath )
    {
        this->isHealthlyConstructed = false;
        this->canOperate = false;
        throw;
    }// else :  healthly built: continue:
    std::ifstream dumpReader(  this->sequentialDumpPath, std::fstream::in );// read-only.
    dumpReader.seekg( 0, dumpReader.end);
    this->actualPrimaryFileLength = dumpReader.tellg(); // TODO eliminate instance-data-members.
    this->secureRightBound = this->actualPrimaryFileLength - this->tailRecordSize;// refresh it now!
    // ready.
    return this->actualPrimaryFileLength;
}//getActualLength


 Cantiere_Primes_2022September01_::Primes::AsinglePointInStream  Cantiere_Primes_2022September01_::Primes::readRecordAt(std::ifstream & dumpReader, long offsetFromBeg)
 {
     AsinglePointInStream res;
    this->getLastCoupleInDefaultFile();// this call writes into members: {lastOrdinal, lastPrime}.
    long target = offsetFromBeg;
    const int tokenSize = this->tailRecordSize;// globally defined.
    char partialToken[tokenSize];
    char secondToken[tokenSize];

        if( secureRightBound<target)// required a landing-point, after the secureRightBound
        {
//            this->dumpTailReaderByChar( this->sequentialDumpPath);
//            this->recoverDumpTail( this->theDumpTailStr);
//            for(int c=0; ; c++)
//            {// scan the dumpTailArray
//                if( c>this->actualCoupleCardinality-1)
//                {
//                    throw "element not found in file tail.";
//                }
//                if( requiredOrdinal==dumpTail[c].ordinal)
//                {
//                    decodedOrdinal = dumpTail[c].ordinal;// exit condition
//                    requiredPrime = dumpTail[c].prime;
//                    dumpReader.close();// TODO evaluate if leave open for ReadRange()
//                    return requiredPrime;// NB. break is not enough!
//                }// else continue.
//            }// scan the dumpTailArray
        }// required a landing-point, after the secureRightBound
        else
        {// NB. only seek to safe locations(i.e. <=secureRightBound) otherwise the flag-family isBad,isEOF will throw something.
            dumpReader.seekg( target, dumpReader.beg);// GOTO required %.##################################### crucial action #####
        }// after having landed, evaluate:
        // first Token has to be thrown away, since it is likely to be truncated before the beginning, due to
        // random access to seek(bisection); next record will be complete.
        dumpReader.getline( partialToken, tokenSize, '\r' );
        dumpReader.getline( secondToken, tokenSize, '\r' );// read the whole line, until newline.
        if(0==target)//if the landing-point is the beginning of stream, then the useful token is the first one, since there's no previous one.
        {// it's needed only when searching for the first record in the dump, since it has no previous record.
            for( int c=0; c<tokenSize; c++)
            {// mustSwapTokens
                secondToken[c] = partialToken[c];
            }// mustSwapTokens
        }// no else; when searching for records different from the absolute first, there's no need for this swap.
        int partialToken_Length = strlen_loc( partialToken);
        int secondToken_Length = strlen_loc( secondToken);
        int totalReadTokenLength = partialToken_Length+secondToken_Length+2;// +the two '\r' that are descarded.
//         in case of need to Debug the stream seeking.
//        //## functions to check state flags:
//        bool isGood = dumpReader.good();
//        bool isEOF = dumpReader.eof();
//        bool isFailure = dumpReader.fail();
//        bool isBad = dumpReader.bad();
//        bool isRdState = dumpReader.rdstate();
//        if( !isGood
//            ||isEOF
//            ||isFailure
//            ||isBad
//            ||isRdState )
//        {
//            return -1UL;// as an error code, since the correct response has to be >0.
//        }// else continue:
        //## end: functions to check state flags.

        char cStringDivisorSequence[2];
        cStringDivisorSequence[0] = '_';
        cStringDivisorSequence[1] = 0;
        std::vector<std::string> * splittedTokens = Common::StrManipul::stringSplit( cStringDivisorSequence, secondToken, true);
        int hmFoundToken = splittedTokens->size();
        const char * decodedOrdinal_str = nullptr;
        const char * decodedPrime_str = nullptr;
        if(2<=hmFoundToken)// at least ordinal_prime ,i.e. 2 token.
        {
            decodedOrdinal_str = (*splittedTokens)[0].c_str();
            decodedPrime_str = (*splittedTokens)[1].c_str();
        }
        else
        {// TODO: evaluate a throw, due to inconsistent dumpIntegralFile.
            throw;// TODO : manage the error case.
        }
        // TODO : manage exception on parsing.
        res.Ordinal = Common::StrManipul::stringToUnsignedLong( decodedOrdinal_str);// TODO : manage exception on parsing. test:
        if( res.Ordinal>this->lastOrdinal)
        {
            throw;// TODO : manage the error case.
        }
        dumpReader.seekg( -1*totalReadTokenLength, dumpReader.cur );// GO back, of the read amount.########### crucial action #####
        long presentPosition = dumpReader.tellg();//#### NB. ####
     // trascrizione dei risultati:
     res.Prime = (long)Common::StrManipul::stringToUnsignedLong( decodedPrime_str);
     res.positionByte = presentPosition;
    // clanup:
    delete splittedTokens;
    //delete decodedOrdinal_str;//NB. already deleted, as parts of splittedTokens.
    //delete decodedPrime_str;
     // ready.
     return res;
 }// readRecordAt(



 // prototypes for this criterion:
 // double LandingPoint = ( (double)requiredOrdinal / (double)(this->lastOrdinal) ) * usefulPartOfDump_measure;// NB. crucial ####
   int Cantiere_Primes_2022September01_::Primes::NpartSection( const  long requiredOrdinal, const  long initialization, bool wantInitialization )
 {
    long MassimoMinoranti, MinimoMaggioranti;// NB. have to be signed.
    double DeltaTessutoProdotto;
    AsinglePointInStream beg, decoded, last;
    double requiredLandingPoint;
    int target;
    long prevLandingPoint;
    long prevDecodedOrdinal;
    long leftBoundary = 0;
    // init  last : read last record
    std::ifstream dumpReader( this->sequentialDumpPath, std::fstream::in );// read-only.
    this->getActualLength();// this call contains three actions:
    // NB. the previous line refreshes what follows: this->secureRightBound = this->actualPrimaryFileLength - this->tailRecordSize;
    last.Ordinal = this->lastOrdinal;// TODO monitor the compatibility signed-unsigned.
    last.Prime = this->lastPrime;// TODO monitor the compatibility signed-unsigned.
    last.positionByte = this->actualPrimaryFileLength;// TODO monitor the compatibility signed-unsigned.
    long usefulPartOfDump_measure = (long)this->actualPrimaryFileLength;// init. It will be updated bisecting.
    MassimoMinoranti = leftBoundary;// init.
    long rightBoundary = this->actualPrimaryFileLength;
    MinimoMaggioranti = rightBoundary;// init.
    // init   beg : beg is certain; no need to read.
    beg.Ordinal = +1;
    beg.Prime = +2;
    beg.positionByte = 0;
     // init
     if( ! wantInitialization)
     {
         requiredLandingPoint = ( (double)requiredOrdinal / (double)(this->lastOrdinal) ) *(double)(this->actualPrimaryFileLength);// NB. crucial ####
     }
     else
     {
         requiredLandingPoint = initialization;
     }
     prevLandingPoint = 0;//init; NB.do not trigger the booster, initializing=LandingPoint.
     prevDecodedOrdinal = 0;//init; NB.do not trigger the booster.
     // init   decoded
     decoded.Ordinal = -1;// init to invalid, to enter the loop.test.Ordinal;
     decoded.Prime =  -1;// init to invalid, to enter the loop.
     decoded.positionByte =  -1;// init to invalid, to enter the loop.
     // ####
     int acc=0;// accumulator of steps, needed to converge.
     for( ; requiredOrdinal!=decoded.Ordinal; acc++)
     {
         // here do: seekg #############
         target = (int)requiredLandingPoint;
         AsinglePointInStream test = this->readRecordAt( dumpReader, target);
         decoded.Ordinal = test.Ordinal;
         decoded.Prime = test.Prime;
         decoded.positionByte = test.positionByte;
        if( decoded.Ordinal<requiredOrdinal)// #### landingPoint evaluation #####
        {// bisection forward : right leaf
           if( decoded.positionByte > MassimoMinoranti)
            {
                MassimoMinoranti = decoded.positionByte;
            }// else MassimoMinoranti is already better than that.
            // MinimoMaggioranti =  this->actualPrimaryFileLength; already got it from init.
        }
        else if( decoded.Ordinal > requiredOrdinal)
        {// bisection backward : left leaf
            // leftBoundary = 0; already got it from init.
            if(decoded.positionByte-this->tailRecordSize < MinimoMaggioranti)
            {
                MinimoMaggioranti = decoded.positionByte-this->tailRecordSize; //-totalReadTokenLength;
            }// else MinimoMaggioranti is already better than that.
        }
        else// i.e.  decoded.Ordinal == requiredOrdinal
        {
            // restituire  decoded.Prime
            break;
        }
        // common factors:
        leftBoundary = MassimoMinoranti;// keep memory of previous narrowings.
        rightBoundary = MinimoMaggioranti;// keep memory of previous narrowings.
        usefulPartOfDump_measure = rightBoundary - leftBoundary;
        requiredLandingPoint = ( (double)requiredOrdinal / (double)(this->lastOrdinal) ) *(double)(usefulPartOfDump_measure)+leftBoundary;// NB. crucial ####
        if(requiredLandingPoint <0) {requiredLandingPoint=0;}
        if(requiredLandingPoint >this->actualPrimaryFileLength ) {requiredLandingPoint=this->actualPrimaryFileLength;}
        if( requiredLandingPoint==prevLandingPoint || decoded.Ordinal==prevDecodedOrdinal)
        {
            if( decoded.Ordinal<requiredOrdinal)
            {
                requiredLandingPoint+=this->tailRecordSize*3;// boost right.
            }
            else if( decoded.Ordinal > requiredOrdinal)
            {
                requiredLandingPoint-=this->tailRecordSize*3;// boost left.
            }// no other else, since if decoded.Ordinal == requiredOrdinal method already broken the "for".
        }// end prevLandingPoint analysis (i.e. booster).
        if(requiredLandingPoint <0) {requiredLandingPoint=0;}
        if(requiredLandingPoint >this->actualPrimaryFileLength ) {requiredLandingPoint=this->actualPrimaryFileLength;}
        prevLandingPoint = requiredLandingPoint;// anyway, log the current requiredLandingPoint, for usage in the next step.
        prevDecodedOrdinal = decoded.Ordinal;
     }// for
     //###
     dumpReader.close();
     //ready.
     return acc;
 }// NpartSection


  int Cantiere_Primes_2022September01_::Primes::Bisection( const  long requiredOrdinal, const  long initialization, bool wantInitialization )
 {
     long MassimoMinoranti, MinimoMaggioranti;// NB. have to be signed.
     double DeltaTessutoProdotto;
    AsinglePointInStream beg, decoded, last;
    long LandingPoint;
    long prevLandingPoint;
    long prevDecodedOrdinal;
    long leftBoundary = 0;
    // init  last : read last record
    std::ifstream dumpReader( this->sequentialDumpPath, std::fstream::in );// read-only.
    this->getActualLength();// this call contains three actions:
    // NB. the previous line refreshes what follows: this->secureRightBound = this->actualPrimaryFileLength - this->tailRecordSize;
    last.Ordinal = this->lastOrdinal;// TODO monitor the compatibility signed-unsigned.
    last.Prime = this->lastPrime;// TODO monitor the compatibility signed-unsigned.
    last.positionByte = this->actualPrimaryFileLength;// TODO monitor the compatibility signed-unsigned.
    long usefulPartOfDump_measure = (long)this->actualPrimaryFileLength;// init. It will be updated bisecting.
    MassimoMinoranti = leftBoundary;// init.
    long rightBoundary = this->actualPrimaryFileLength;
    MinimoMaggioranti = rightBoundary;// init.
    // init   beg : beg is certain; no need to read.
    beg.Ordinal = +1;
    beg.Prime = +2;
    beg.positionByte = 0;
     // init
     if( ! wantInitialization)
     {
         LandingPoint = (long)(  0.5 * (double)last.positionByte  );//bisect
     }
     else
     {
         LandingPoint = initialization;
     }
     prevLandingPoint = 0;//init; NB.do not trigger the booster, initializing=LandingPoint.
     prevDecodedOrdinal = 0;//init; NB.do not trigger the booster.
     // init   decoded
     decoded.Ordinal = -1;// init to invalid, to enter the loop.test.Ordinal;
     decoded.Prime =  -1;// init to invalid, to enter the loop.
     decoded.positionByte =  -1;// init to invalid, to enter the loop.
     // ####
     int acc=0;// accumulator of steps, needed to converge.
     for( ; requiredOrdinal!=decoded.Ordinal; acc++)
     {
         // here do: seekg #############
         AsinglePointInStream test = this->readRecordAt( dumpReader, LandingPoint);
         decoded.Ordinal = test.Ordinal;
         decoded.Prime = test.Prime;
         decoded.positionByte = test.positionByte;
        if( decoded.Ordinal<requiredOrdinal)// #### landingPoint evaluation #####
        {// bisection forward : right leaf
           if( decoded.positionByte > MassimoMinoranti)
            {
                MassimoMinoranti = decoded.positionByte;
            }// else MassimoMinoranti is already better than that.
            // MinimoMaggioranti =  this->actualPrimaryFileLength; already got it from init.
        }
        else if( decoded.Ordinal > requiredOrdinal)
        {// bisection backward : left leaf
            // leftBoundary = 0; already got it from init.
            if(decoded.positionByte-this->tailRecordSize < MinimoMaggioranti)
            {
                MinimoMaggioranti = decoded.positionByte-this->tailRecordSize; //-totalReadTokenLength;
            }// else MinimoMaggioranti is already better than that.
        }
        else// i.e.  decoded.Ordinal == requiredOrdinal
        {
            // restituire  decoded.Prime
            break;
        }
        // common factors:
        leftBoundary = MassimoMinoranti;// keep memory of previous narrowings.
        rightBoundary = MinimoMaggioranti;// keep memory of previous narrowings.
        usefulPartOfDump_measure = rightBoundary - leftBoundary;
        LandingPoint = (long)( 0.5*usefulPartOfDump_measure+leftBoundary);//NB. add "leftBoundary", to fit the actual stream.
        if(LandingPoint <0) {LandingPoint=0;}
        if(LandingPoint >this->actualPrimaryFileLength ) {LandingPoint=this->actualPrimaryFileLength;}
        if( LandingPoint==prevLandingPoint || decoded.Ordinal==prevDecodedOrdinal)
        {
            if( decoded.Ordinal<requiredOrdinal)
            {
                LandingPoint+=this->tailRecordSize/2;// boost right.
            }
            else if( decoded.Ordinal > requiredOrdinal)
            {
                LandingPoint-=this->tailRecordSize/2;// boost left.
            }// no other else, since if decoded.Ordinal == requiredOrdinal method already broken the "for".
        }// end prevLandingPoint analysis (i.e. booster).
        prevLandingPoint = LandingPoint;// anyway, log the current LandingPoint, for usage in the next step.
        prevDecodedOrdinal = decoded.Ordinal;
     }// for
     //###
     dumpReader.close();
     //ready.
     return acc;
 }// Bisection


 int Cantiere_Primes_2022September01_::Primes::currentOperatorSquare( const  long requiredOrdinal, const  long initialization, bool wantInitialization )
 {
    AsinglePointInStream beg, decoded, last;
    this->feedDumpPath();
    if( nullptr == this->sequentialDumpPath)
    {
        return -1UL;// as an error code, since the correct response has to be >0.
    }// else continue:
    unsigned long requiredPrime;
    std::ifstream dumpReader( this->sequentialDumpPath, std::fstream::in );// read-only.
    this->getActualLength();//
    long usefulPartOfDump_measure = this->actualPrimaryFileLength;// init. It will be updated bisecting.
    long leftBoundary = 0;
    long rightBoundary = this->actualPrimaryFileLength;
    // start bisecting:
    this->getLastCoupleInDefaultFile();// this call writes into members: {lastOrdinal, lastPrime}.
    if( requiredOrdinal>this->lastOrdinal// NB. do NOT attempt reading after EOF, which throws.
        || requiredOrdinal<=0 )
    {
        return -1UL;// as an error code, since the correct response has to be >0.
    }// else continue:
    double requiredLandingPoint = ( (double)requiredOrdinal / (double)(this->lastOrdinal) ) * usefulPartOfDump_measure;// NB. crucial ####
    int target;
    const int tokenSize = this->tailRecordSize;// globally defined.
    char partialToken[tokenSize];
    char secondToken[tokenSize];
    unsigned long decodedOrdinal = -1UL;
    //
    int acc=0;// accumulator of steps, needed to converge.
    for( ; requiredOrdinal!= decodedOrdinal; acc++)
    {// loop della bisezione:
        target = (int)(requiredLandingPoint);// find required %.
         AsinglePointInStream test = this->readRecordAt( dumpReader, target);
         decoded.Ordinal = test.Ordinal;
         decoded.Prime = test.Prime;
         decoded.positionByte = test.positionByte;


        dumpReader.seekg( target, dumpReader.beg);// GOTO required %.##################################### crucial action #####

        // first Token has to be thrown away, since it is likely to be truncated before the beginning, due to
        // random access to seek(bisection); next record will be complete.
        dumpReader.getline( partialToken, tokenSize, '\r' );
        dumpReader.getline( secondToken, tokenSize, '\r' );// read the whole line, until newline.
        if(0==target)//if the landing-point is the beginning of stream, then the useful token is the first one, since there's no previous one.
        {// it's needed only when searching for the first record in the dump, since it has no previous record.
            for( int c=0; c<tokenSize; c++)
            {// mustSwapTokens
                secondToken[c] = partialToken[c];
            }// mustSwapTokens
        }// no else; when searching for records different from the absolute first, there's no need for this swap.
        int partialToken_Length = strlen_loc( partialToken);
        int secondToken_Length = strlen_loc( secondToken);
        int totalReadTokenLength = partialToken_Length+secondToken_Length+2;// +the two '\r' that are descarded.
        in case of need to Debug the stream seeking.
        //## functions to check state flags:
        bool isGood = dumpReader.good();
        bool isEOF = dumpReader.eof();
        bool isFailure = dumpReader.fail();
        bool isBad = dumpReader.bad();
        bool isRdState = dumpReader.rdstate();
        if( !isGood
            ||isEOF
            ||isFailure
            ||isBad
            ||isRdState )
        {
            return -1UL;// as an error code, since the correct response has to be >0.
        }// else continue:
        //## end: functions to check state flags.
        //
        char cStringDivisorSequence[2];
        cStringDivisorSequence[0] = '_';
        cStringDivisorSequence[1] = 0;
        std::vector<std::string> * splittedTokens = Common::StrManipul::stringSplit( cStringDivisorSequence, secondToken, true);
        int hmFoundToken = splittedTokens->size();
        const char * decodedOrdinal_str = nullptr;
        const char * decodedPrime_str = nullptr;
        if(2<=hmFoundToken)// at least ordinal_prime ,i.e. 2 token.
        {
            decodedOrdinal_str = (*splittedTokens)[0].c_str();
            decodedPrime_str = (*splittedTokens)[1].c_str();
        }
        else
        {// TODO: evaluate a throw, due to inconsistent dumpIntegralFile.
            return -1UL;// as an error code, since the correct response has to be >0.
        }
        // TODO : manage exception on parsing.
        decodedOrdinal = Common::StrManipul::stringToUnsignedLong( decodedOrdinal_str);// TODO : manage exception on parsing. test:
        if( decodedOrdinal>this->lastOrdinal)
        {
            return -1UL;// as an error code, since the correct response has to be >0.
        }
        long presentPosition = dumpReader.tellg();//#### NB. ####
        if( decodedOrdinal<requiredOrdinal)// #### landingPoint evaluation #####
        {// bisection forward : right leaf
            leftBoundary = presentPosition;
            rightBoundary = this->actualPrimaryFileLength;
        }
        else if( decodedOrdinal > requiredOrdinal)
        {// bisection backward : left leaf
            leftBoundary = 0;
            rightBoundary = presentPosition-totalReadTokenLength;
        }
        else// i.e.  decodedOrdinal == requiredOrdinal
        {
            requiredPrime =  Common::StrManipul::stringToUnsignedLong( decodedPrime_str);
            break;
        }
        // common factors:
        usefulPartOfDump_measure = rightBoundary - leftBoundary;
        requiredLandingPoint = ( (double)requiredOrdinal / (double)decodedOrdinal ) * usefulPartOfDump_measure;
        // clanup:
        delete splittedTokens;
        //delete decodedOrdinal_str;//NB. already deleted, as parts of splittedTokens.
        //delete decodedPrime_str;
    }// loop della bisezione.
    // ready.
    dumpReader.close();// TODO evaluate if leave open for ReadRange()
    return acc;// steps to converge
 }//currentOperatorSquare(


 // suggestions for bug-fixing on index[1]
 // on seekg(0, begin) swap partial_token and second_token, since there's no previous token, with respect to the first one. DONE
 // on seekg(0, end ) : cannot read more than the remaining bytes to EOF. So cannot seekg past (filesize-recordLength). DONE.
 // on assignement const int tokenSize = 60; evaluate a dynamic size. DONE: global dataMember tailRecordSize==60.
 //
// it's a utility; syntax: Prime[ordinal]==...
unsigned long   Cantiere_Primes_2022September01_::Primes::operator[] ( const unsigned long requiredOrdinal )
{// linear bisection on IntegralFile.
    this->feedDumpPath();
    if( nullptr == this->sequentialDumpPath)
    {
        return -1UL;// as an error code, since the correct response has to be >0.
    }// else continue:
    unsigned long requiredPrime;
    std::ifstream dumpReader( this->sequentialDumpPath, std::fstream::in );// read-only.
    this->getActualLength();// ths call contains the three actions, deleted below.
    // NB. the previous line refreshes what follows: this->secureRightBound = this->actualPrimaryFileLength - this->tailRecordSize;
//    dumpReader.seekg( 0, dumpReader.end);
//    long dumpSize = dumpReader.tellg();
//long secureRightBound = dumpSize - this->tailRecordSize;
    long usefulPartOfDump_measure = this->actualPrimaryFileLength;// init. It will be updated bisecting.
    long leftBoundary = 0;
    long rightBoundary = this->actualPrimaryFileLength;
    // start bisecting:
    this->getLastCoupleInDefaultFile();// this call writes into members: {lastOrdinal, lastPrime}.
    if( requiredOrdinal>this->lastOrdinal// NB. do NOT attempt reading after EOF, which throws.
        || requiredOrdinal<=0 )
    {
        return -1UL;// as an error code, since the correct response has to be >0.
    }// else continue:
    double requiredLandingPoint = ( (double)requiredOrdinal / (double)(this->lastOrdinal) ) * usefulPartOfDump_measure;// NB. crucial ####
    int target;
    const int tokenSize = this->tailRecordSize;// globally defined.
    char partialToken[tokenSize];
    char secondToken[tokenSize];
    unsigned long decodedOrdinal = -1UL;
    //
    for( ; requiredOrdinal!= decodedOrdinal;)
    {// loop della bisezione:
        target = (int)(requiredLandingPoint);// find required %.
        if( secureRightBound<target)// required a landing-point, after the secureRightBound
        {
            this->dumpTailReaderByChar( this->sequentialDumpPath);
            this->recoverDumpTail( this->theDumpTailStr);
            for(int c=0; ; c++)
            {// scan the dumpTailArray
                if( c>this->actualCoupleCardinality-1)
                {
                    throw "element not found in file tail.";
                }
                if( requiredOrdinal==dumpTail[c].ordinal)
                {
                    decodedOrdinal = dumpTail[c].ordinal;// exit condition
                    requiredPrime = dumpTail[c].prime;
                    dumpReader.close();// TODO evaluate if leave open for ReadRange()
                    return requiredPrime;// NB. break is not enough!
                }// else continue.
            }// scan the dumpTailArray
        }// required a landing-point, after the secureRightBound
        else
        {// NB. only seek to safe locations(i.e. <=secureRightBound) otherwise the flag-family isBad,isEOF will throw something.
            dumpReader.seekg( target, dumpReader.beg);// GOTO required %.##################################### crucial action #####
        }// after having landed, evaluate:
        // first Token has to be thrown away, since it is likely to be truncated before the beginning, due to
        // random access to seek(bisection); next record will be complete.
        dumpReader.getline( partialToken, tokenSize, '\r' );
        dumpReader.getline( secondToken, tokenSize, '\r' );// read the whole line, until newline.
        if(0==target)//if the landing-point is the beginning of stream, then the useful token is the first one, since there's no previous one.
        {// it's needed only when searching for the first record in the dump, since it has no previous record.
            for( int c=0; c<tokenSize; c++)
            {// mustSwapTokens
                secondToken[c] = partialToken[c];
            }// mustSwapTokens
        }// no else; when searching for records different from the absolute first, there's no need for this swap.
        int partialToken_Length = strlen_loc( partialToken);
        int secondToken_Length = strlen_loc( secondToken);
        int totalReadTokenLength = partialToken_Length+secondToken_Length+2;// +the two '\r' that are descarded.
//      in case of need to Debug the stream seeking.
//        //## functions to check state flags:
//        bool isGood = dumpReader.good();
//        bool isEOF = dumpReader.eof();
//        bool isFailure = dumpReader.fail();
//        bool isBad = dumpReader.bad();
//        bool isRdState = dumpReader.rdstate();
//        if( !isGood
//            ||isEOF
//            ||isFailure
//            ||isBad
//            ||isRdState )
//        {
//            return -1UL;// as an error code, since the correct response has to be >0.
//        }// else continue:
//        //## end: functions to check state flags.
//
        char cStringDivisorSequence[2];
        cStringDivisorSequence[0] = '_';
        cStringDivisorSequence[1] = 0;
        std::vector<std::string> * splittedTokens = Common::StrManipul::stringSplit( cStringDivisorSequence, secondToken, true);
        int hmFoundToken = splittedTokens->size();
        const char * decodedOrdinal_str = nullptr;
        const char * decodedPrime_str = nullptr;
        if(2<=hmFoundToken)// at least ordinal_prime ,i.e. 2 token.
        {
            decodedOrdinal_str = (*splittedTokens)[0].c_str();
            decodedPrime_str = (*splittedTokens)[1].c_str();
        }
        else
        {// TODO: evaluate a throw, due to inconsistent dumpIntegralFile.
            return -1UL;// as an error code, since the correct response has to be >0.
        }
        // TODO : manage exception on parsing.
        decodedOrdinal = Common::StrManipul::stringToUnsignedLong( decodedOrdinal_str);// TODO : manage exception on parsing. test:
        if( decodedOrdinal>this->lastOrdinal)
        {
            return -1UL;// as an error code, since the correct response has to be >0.
        }
        long presentPosition = dumpReader.tellg();//#### NB. ####
        if( decodedOrdinal<requiredOrdinal)// #### landingPoint evaluation #####
        {// bisection forward : right leaf
            leftBoundary = presentPosition;
            rightBoundary = this->actualPrimaryFileLength;
        }
        else if( decodedOrdinal > requiredOrdinal)
        {// bisection backward : left leaf
            leftBoundary = 0;
            rightBoundary = presentPosition-totalReadTokenLength;
        }
        else// i.e.  decodedOrdinal == requiredOrdinal
        {
            requiredPrime =  Common::StrManipul::stringToUnsignedLong( decodedPrime_str);
            break;
        }
        // common factors:
        usefulPartOfDump_measure = rightBoundary - leftBoundary;
        requiredLandingPoint = ( (double)requiredOrdinal / (double)decodedOrdinal ) * usefulPartOfDump_measure;
        // clanup:
        delete splittedTokens;
        //delete decodedOrdinal_str;//NB. already deleted, as parts of splittedTokens.
        //delete decodedPrime_str;
    }// loop della bisezione.
    // ready.
    dumpReader.close();// TODO evaluate if leave open for ReadRange()
    return requiredPrime;
}// operator[]

 // what is its role ??
 int Cantiere_Primes_2022September01_::Primes::shiftInSumTissue( const  long requiredOrdinal, const  long initialization, bool wantInitialization )
 {
     long DeltaTessutoSomma;// NB. have to be signed, cause of signedDelta.
     double DeltaTessutoProdotto;
     struct AsinglePointInStream
     {
         long Ordinal;
         long Prime;
         long positionByte;
     };
     AsinglePointInStream beg, decoded, last;
     long LandingPoint;
     // init   beg
     beg.Ordinal = +1;
     beg.Prime = +2;
     beg.positionByte = 0;
     // init  last
     last.Ordinal = +100;// case study
     last.Prime = +541;
     last.positionByte = +600;//per eccesso
     // init
     if( ! wantInitialization)
     {
         LandingPoint = (long)(  (double)requiredOrdinal/(double)last.Ordinal * (double)last.positionByte  );
     }
     else
     {
         LandingPoint = initialization;
     }
     // init   decoded
     decoded.Ordinal = LandingPoint * +1/+1.91; // [Dim]==[ordinal]
     //Hypothesis: position==f(ordinal)==+1.91*ordinal
     decoded.positionByte = +1.91 * LandingPoint;
     decoded.Prime = 0;
     // ####
     int acc=0;// accumulator of steps, needed to converge.
     for( ; requiredOrdinal!=decoded.Ordinal; acc++)
     {
         DeltaTessutoSomma = requiredOrdinal - decoded.Ordinal;
         DeltaTessutoProdotto = (double)DeltaTessutoSomma/(double)(last.positionByte);
         LandingPoint =  decoded.positionByte + DeltaTessutoProdotto*last.positionByte;// [Dim]==[position]
         // simulation
         decoded.positionByte = LandingPoint;
         decoded.Ordinal = LandingPoint * +1/+1.91; // [Dim]==[ordinal]
     }// for
     //###
     //ready.
     return acc;
 }// PropostaBisezione



void tryReadBackwards()// platform dependent.
{// NB. works on Linux but not on Windows.
    std::ifstream in;
    in.open("nelMezzo.txt");
    char ch;
    int pos;
    in.seekg(-1,ios::end);
    pos=in.tellg();
    for(int i=0;i<pos;i++)
    {
        ch=in.get();
        cout<<ch;
        in.seekg(-2,ios::cur);
    }
    in.close();
}//tryReadBackwards

void tryReadForewards()
{
    std::ifstream in;
    in.open("nelMezzo.txt");
    char ch;
    int pos;
    in.seekg(-1,ios::end);
    pos=in.tellg();
    in.seekg(0,ios::beg );// go back to the starting point.
    for(int i=0;i<pos;i++)
    {
        ch=in.get();
        cout<<ch;
        // NB. no seek reading forewards; it's implicitly in.seekg(+1,ios::cur);
    }
    in.close();
}//tryReadBackwards


    int bisectionConvergenceSteps = p->Bisection( 73, 100, false);
    for(int c=1; c<=100;c++)// NB. you cannot require an ordinal<+1.
    {
        std::cout << "\n\t converging in " << p->Bisection( c, 100, false) <<" steps."<<std::endl;
    }
    //int NsectionConvergenceSteps = p->NpartSection( 73, 100, false);
    for(int c=73; c<=100;c++)
    {
        std::cout<<" steps for Bisection to converge to LandingPoint_"<<c<<" are:"<< p->Bisection( c, 100, false)<<std::endl;
        std::cout<<" steps for NpartSection to converge to LandingPoint_"<<c<<" are:"<< p->NpartSection( c, 100, false)<<std::endl;
    }

//    as is
//    "testCowsCanBeMilked"
//    "testSheepAreNotTheOnlyFruit"
//    // to be
//    "Cows can be milked"
//    "Sheep are not the only fruit"
//

    std::vector<std::string> * camelToken = nullptr;// many usages: allocated & deleted each time.
    //
    std::string * original_one = new std::string("testCowsCanBeMilked");
    testCallerQuestTwo( original_one);

    std::string * original_two = new std::string("testSheepAreNotTheOnlyFruit");
    testCallerQuestTwo( original_two);

    std::string * original_three = new std::string("testSheep WrittenNot123#So23@Good really");
    testCallerQuestTwo( original_two);


char toLower(const char par)
{
    if( (int)par>=65 && (int)par<=90)
    {
        return ( (char)((int)(par)+32));
    }
    else
    {
        return par;// if it's not an upper case letter, don't convert it.
    }
}

bool isUpper(const char par)
{
    bool res = false;
    if( (int)par>=65 && (int)par<=90)
    {
        res = true;
    }// else stay false.
    //    if( (int)par>=97 && (int)par<=122)
    //    {
    //        res = false;
    //    } this is should be for lower case
    // done
    return res;
}



// as is
//"testCowsCanBeMilked"
//"testSheepAreNotTheOnlyFruit"
//// to be
//"Cows can be milked"
//"Sheep are not the only fruit"
//
std::vector<std::string> * camelTokenizer( const std::string * original_one )
{
    std::vector<std::string> * camelToken = new std::vector<std::string>();
    Common::StringBuilder * curToken = new Common::StringBuilder( original_one->length());// round in excess
    // if(curChar is NOT upper -> pushBack)
    // else if(curChar is upper -> terminateCurStrBuilder -> Start a new one with toLower(curChar) )
    //
    int c=0;//needed after endOfLoop
    for( ; c<original_one->length(); c++)
    {
        if( ! isUpper( original_one->at(c) ) )
        {
            curToken->append( original_one->at(c) );
        }
        else // not upper
        {
            camelToken->push_back( curToken->str() );
//std::cout<< curToken->str() <<std::endl;
            delete curToken;
            curToken = nullptr;
            curToken = new Common::StringBuilder( original_one->length());// get ready for another one
            curToken->append( toLower( original_one->at(c) ) );
        }// end else  not upper
    }// end for
    //---recover last token, which has no capitalLetter to signal its registration
    camelToken->push_back( curToken->str() );
//std::cout<< curToken->str() <<std::endl;
    delete curToken;
    curToken = nullptr;
    // no successive token, to get ready for.
    return camelToken;
}// end camelTokenizer(


void testCallerQuestTwo( const std::string * original_one )
{
    std::vector<std::string> * camelToken = camelTokenizer( original_one);
    // rewind
    for( std::vector<std::string>::iterator theTokens=camelToken->begin();
        theTokens != camelToken->end();
        theTokens++
    )
    {
        std::cout << *theTokens << " ";
    }
    std::cout << std::endl;
    delete original_one;
    delete camelToken;
}// end testCallerQuestTwo(



/// l'integrando (-z)^s/(Exp[z]-1)dz/z
Numerics::Complex * IcoChain( Numerics::Complex s, Numerics::Complex z)
{
    Numerics::Complex numerator(-z);
    numerator ^=s;
    Numerics::Complex denominator((z.ExpC()-1.0)*z);
    Numerics::Complex * res = new Numerics::Complex( numerator / denominator);//---caller has to delete----------
    return res;
}// IcoChain


Numerics::Complex * pointFromOriginAnulus( double delta, double Theta )
{// this parametrization is: (delta*Cos[t] + I*delta*Sin[t])
    // take the desired point, on the unit ball: i.e. the versor.
    Numerics::Complex * res = new Numerics::Complex( cos(Theta) , sin(Theta) );//NB. caller has to delete.
    *res *= delta;// then take it on the appropriate ball, by omothetia.
    return res;
}// pointFromOriginAnulus


Numerics::Complex * originAnulus( double stepSize, int stepOrdinal, double delta)
{// this parametrization is: (delta*Cos[t] + I*delta*Sin[t])
    Domain domain;//to be thrown
    int stepCardinality = +2.0*PI/stepSize;
    if(stepOrdinal>stepCardinality){throw domain;}
    double Theta = +2.0*PI*(double)stepOrdinal/(double)stepCardinality;
    Numerics::Complex * res = new Numerics::Complex( cos(Theta) , sin(Theta) );//NB. caller has to delete.
    *res *= delta;
    return res;
}// originAnulus


// NB. cannot step for numerical integration in Complex plane like this: the real and immaginary parts of the image( i.e. u(x,y) and v(x,y) ) have
// to be separated, to step.
Numerics::Complex * integralStepIntoOriginAnulus( double stepSize, double radius, Numerics::Complex s)
{// this parametrization is: (radius*Cos[t] + I*radius*Sin[t])
    Numerics::Complex * accumulator = new Numerics::Complex( 0.0 , 0.0);
    int stepCardinality = +2.0*PI/stepSize;
    double Theta =0.0;
    for(int curStep=0; curStep<stepCardinality; curStep++)
    {
        Theta = +2.0*PI*(double)curStep/(double)stepCardinality;
        Numerics::Complex * pointOnCircularChain = pointFromOriginAnulus( radius, Theta );
        Numerics::Complex * pointOn_COchain = IcoChain( s, *pointOnCircularChain);
        *accumulator += *pointOn_COchain;
        delete pointOnCircularChain;
        delete pointOn_COchain;
    }
    return accumulator;// caller has to delete.
}// originAnulus


Numerics::Complex * imageStepIntoOriginAnulus( double stepSize, double radius, Numerics::Complex s, int curStep)
{// this parametrization is: (radius*Cos[t] + I*radius*Sin[t])
    int stepCardinality = +2.0*PI/stepSize;
    double Theta =0.0;
    Theta = +2.0*PI*(double)curStep/(double)stepCardinality;
    Numerics::Complex * pointOnCircularChain = pointFromOriginAnulus( radius, Theta );
    Numerics::Complex * pointOn_COchain = IcoChain( s, *pointOnCircularChain);
    delete pointOnCircularChain;
    //
    return pointOn_COchain;// caller has to delete.
}// originAnulus

Numerics::Complex * imageStepIntoLinearHankelBranch( Numerics::Complex s, Numerics::Complex z)
{// this parametrization is: z=:(t  + I*epsilon). It is used both to go from +Infinity to the origin and back.
    Numerics::Complex * pointOn_COchain = IcoChain( s, z);
    return pointOn_COchain;// caller has to delete.
}// originAnulus


//    PrimesFinder::Primes p(100);
//    bool CtorStatus = p.isHealthlyConstructed;
//    int64_t aPrime = p[20];

//    Numerics::Complex s(+0.35, +20.15);
//    const double epsilon = -9.0;// a macro distance
//    const double step = +1.0;// a macro step
//    Numerics::Complex z( fabs(epsilon), epsilon);
//    int stepCardinality = 10;
//    //
//    //--dump on txtFile ----------------------------
//	std::string thePath("./out20220219_.txt");// TODO read with Java and push to PostgreSql.
//	std::fstream theStream;
//	bool result = Common::Stream::outstreamOpener( thePath , theStream );
//    std::string * curField = nullptr;
//
//
//    // calculate each image point via the coChain (-x)^s/(x*(Exp[x]-1))dx (x is a Complex variable here).
//    Numerics::Complex * imagePoint = nullptr;
//    for(int curStep=0; curStep<stepCardinality; curStep++)
//    {
//        Common::StringBuilder sb(90);// the stringBuilder needs to be reset at every loop-step.
//        imagePoint = imageStepIntoLinearHankelBranch( s, z);//-----calculation------the imagePoint gets allocated inside the calculation and gets freed at each for-step.
//        //-----prepare the StringBuilder for a single line------
//        //------------------------------- s ----------------------------------------------------
//        curField = Common::StrManipul::doubleToString( s.Re() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( s.Im() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        //------------------------------- z ----------------------------------------------------
//        curField = Common::StrManipul::doubleToString( z.Re() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( z.Im() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        //------------------------------- image ----------------------------------------------------
//        curField = Common::StrManipul::doubleToString( imagePoint->Re() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( imagePoint->Im() );
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //----------------------------------------this last parameter end the line, in the txtDump.----------------------------
//        //--------update params-------------------------------
//        z += Numerics::Complex( step, 0);// Hankel linear branches require to stay parallel to the abscissa.
//        //
//        //-----finally dump the line
//        Common::Stream::putline( sb.str() , theStream);//---this appends a \n
//        delete imagePoint;
//    }
//    result = Common::Stream::outstreamCloser( theStream );// only after the complete loop, close the dumpStream.
    double radius = +3.7123E+01;
    double stepSize = +2.0*PI/900.0;
=======

int main()
{
//    Numerics::Complex z(+3.1 , 5.2);
//    for( int n=0; n<6; n++)
//    {
////        Numerics::Complex  curExponent((double)n, 0.0);
////        Numerics::Complex res = z^curExponent;
//        Numerics::Complex res = z^n;
//        std::cout<<"\n\t("<<z.Re()<<"+I*"<<z.Im()<<")^"<<n<<" == "<< res.Re()<<"+I*"<<res.Im();
//    }
////
////For[
//// t = 1; base = +2.1*t + I*3.1*t; espon = +2.3*t + I*1.6*t;,
//// t < 6,
//// Print["t==", t, " base^espon==" , base, "^", espon, " == ",
////  base^espon  ];
//// t += +0.4;
//// base = +2.1*t + I*3.1*t;
//// espon = +2.3*t + I*1.6*t;
//// ]
//for( double t=+1.0; t<+6.0; t+=+0.4 )
//{
//    Numerics::Complex base ( +2.1*t , 3.1*t );
//    Numerics::Complex espon( +2.3*t , 1.6*t );
//    Numerics::Complex res = base^espon;
//    std::cout<<"\n\t("<<base.Re()<<"+I*"<<base.Im()<<")^"<<
//                   "("<<espon.Re()<<"+I*"<<espon.Im()<<") == "<< res.Re()<<"+I*"<<res.Im();
//}

//for( double t=+91.0; t<+116.0; t+=+0.4 )
//{
//    Numerics::Complex espon( +2.3*t , 1.6*t );
//    Numerics::Complex res = espon.ExpC();
//    Numerics::Complex res_selfish = espon.ExpC_selfish();
//    std::cout<<"\n\t Exp["<<espon.Re()<<"+I*"<<espon.Im()<<"] == "<< res.Re()<<"+I*"<<res.Im()<<
//    "  selfish: "<< res_selfish.Re()<<"+I*"<<res_selfish.Im();
//}

	std::string thePath("./out20220219_.txt");
	std::fstream theStream;
	//
	bool result = Common::Stream::outstreamOpener( thePath , theStream );
    double radius = +3.7123E+01;
    double stepSize = +2.0*PI/900.0;
    Numerics::Complex s(+0.35, +20.15);
    Numerics::Complex * integralOnOriginAnulus = integralStepIntoOriginAnulus( stepSize, radius, s);
    std::string * curField = nullptr;
    Common::StringBuilder sb(90);
    //
    curField = Common::StrManipul::doubleToString( integralOnOriginAnulus->Re() );
    sb.append( *curField );
    sb.append((int)'\t');
    delete curField;
    //
    curField = Common::StrManipul::doubleToString( integralOnOriginAnulus->Im() );
    sb.append( *curField );
    sb.append((int)'\t');
    delete curField;
    //
    //-----finally dump the line
    Common::Stream::putline( sb.str() , theStream);
    result = Common::Stream::outstreamCloser( theStream );
    delete integralOnOriginAnulus;


//    for(int c=0; c<100; c++)
//    {
//        Numerics::Complex * res = originAnulus( stepSize, c, delta );
//        std::cout<<"originAnulus(stepSize,c,delta)=="<<stepSize<<c<<delta<<" == "<< res->Re()<<" +I* "<< res->Im()<<" length=="<< res->length() <<std::endl;
//        Common::StringBuilder sb(90);
//        std::string * curField = nullptr;
//        //
//        curField = Common::StrManipul::doubleToString( stepSize);
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::intToString( c);
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( delta);
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( res->Re());
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( res->Im());
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //
//        curField = Common::StrManipul::doubleToString( res->length());
//        sb.append( *curField );
//        sb.append((int)'\t');
//        delete curField;
//        //-----finally dump the line
//        Common::Stream::putline( sb.str() , theStream);
//        delete res;
//    }
//	result = Common::Stream::outstreamCloser( theStream );

//    Numerics::Complex s(+0.5 , +13.7);
//    Numerics::Complex *z = new Numerics::Complex(1, 3);
//    Numerics::Complex icoChain( IcoChain( s, *z) );
//    delete z;

    //
    std::cout<<"\n\n\n\t Strike Enter to leave\t";
    getchar();
    return 0;
}// main



/* --------------cantina----------------------------

    //PrimesFinder::Primes * p = new PrimesFinder::Primes(100);
//    long desPrime = (*p)[p->lastOrdinal];
//    int bisectionConvergenceSteps = p->Bisection( 73, 100, false);
////for(int c=0; c<=100;c++)
////    {
////        std::cout << "\n\t converging in " << p->Bisection( c, 100, false) <<" steps."<<std::endl;
////    }
//    //int NsectionConvergenceSteps = p->NpartSection( 73, 100, false);
//    for(int c=73; c<=100;c++)
//    {
//        std::cout<<" steps for Bisection to converge to LandingPoint_"<<c<<" are:"<< p->Bisection( c, 100, false)<<std::endl;
//        std::cout<<" steps for NpartSection to converge to LandingPoint_"<<c<<" are:"<< p->NpartSection( c, 100, false)<<std::endl;
//    }
    //delete p;


//    p = new PrimesFinder::Primes(5000000); // re-use
//    p->Start_PrimeDump_FileSys();
//    lastOrdinal = p->getLastOrdinal();
//    lastPrime = p->getLastPrime();
//    presentLength = p->getActualLength();
//
//     unsigned long res = (*p)[25];// TODO bug [lastOrdinal] #######################################################
//     res = (*p)[1];
//     res = (*p)[2];
//     res = (*p)[3];
//     res = (*p)[lastOrdinal];
//     res = (*p)[lastOrdinal-1];
//     res = (*p)[lastOrdinal-2];
//     res = (*p)[lastOrdinal-3];
//     res = (*p)[lastOrdinal-100];
//     if(overflowFlag==res)
//     {
//         std::cout<<"\n\t invalid index fed to operator[] "<<std::endl;
//     }
//     for( int c=1; c<=15; c++)
//     {
//         std::cout<<"\n\t Prime["<<c<<"]=="<<(*p)[c];
//     }
//     for( int c=lastOrdinal-500; c<=lastOrdinal-50; c++)
//     {
//         std::cout<<"\n\t Prime["<<c<<"]=="<<(*p)[c];
//     }
//     const char * theDumpPath = p->getPrimeDumpFullPath( "primeDefaultFile");// Default Section Name.
//     if( nullptr != theDumpPath)
//      {}// else : TODO not-healthly built.
//     const char * straightContentOfDumpTail  = p->dumpTailReader( theDumpPath);
////PrimesFinder::Primes::DumpElement * dumpTail = p->recoverDumpTail( straightContentOfDumpTail);
//     PrimesFinder::Primes::SingleFactor * factorization = p->IntegerDecomposition( (*p)[30123]*7);

////
////     delete[] theDumpPath;
////     delete[] straightContentOfDumpTail;
//     delete[] factorization;
//    //delete[] dumpTail;
//     delete p;

 // MonteCarlo
    double left  = -92.809;
    double right = +12.209;

    int populationCardinality = 9000;
    //
    Common::MonteCarlo::ClassicalDiscreteGenerator * monteCGen =
    new Common::MonteCarlo::ClassicalDiscreteGenerator();// Ctor
    monteCGen->resetExtractionInterval( left, right);// NB. compulsory
    for( int c=0; c<populationCardinality;c++)
    {
        monteCGen->nextIntegerInInterval();
    }
    //monteCGen->showDiscretePopulation();
    monteCGen->buildOmega( left, right );
    monteCGen->buildDiscreteFrequencyDistribution();
    std::cout<<"\n\n\t -------- START discrete model;"<<std::endl;
    monteCGen->showFrequencyDistribution();
    monteCGen->showCumulatedFrequency();
    delete monteCGen;

    std::cout<<"\n\t -------- END discrete model; START continuous model \n"<<std::endl;

    Common::MonteCarlo::ClassicalContinuousGenerator * monteCGen_D =
    new Common::MonteCarlo::ClassicalContinuousGenerator();// Ctor
    monteCGen_D->resetExtractionInterval( left, right);// NB. compulsory
    for( int c=0; c<populationCardinality;c++)
    {
        monteCGen_D->nextDoubleInInterval();
    }
    //monteCGen_D->showContinuousPopulation();
    monteCGen_D->buildOmega( left, right );
    monteCGen_D->buildContinuousFrequencyDistribution();
    monteCGen_D->showFrequencyDistribution();
    monteCGen_D->showCumulatedFrequency();

    delete monteCGen_D;
 // MonteCarlo


  std::string s("Nel mezzo#@# del cammin#@# di nostra vita,#@# mi ritrovai#@#  #@# #@# #@# per una selva oscura#@#.");
  std::vector<std::string> * tokens = Common::StrManipul::stringSplit("#@#", s, false);
  std::vector<std::string> * cleanTokens = Common::StrManipul::removeEmptyEntries( tokens);

  if( NULL != tokens)
  {
  for( std::vector<std::string>::const_iterator readerTk = tokens->begin();
        readerTk != tokens->end();
        readerTk++
     )
    {
        std::cout<< *readerTk<<std::endl;
    }
  }// else skip on NULL.
  //
  if( NULL != cleanTokens)
  {
  for( std::vector<std::string>::const_iterator readerCleanTk = cleanTokens->begin();
        readerCleanTk != cleanTokens->end();
        readerCleanTk++
     )
    {
        std::cout<< *readerCleanTk<<std::endl;
    }
  }// else skip on NULL.
  //
  delete tokens;
  delete cleanTokens;


    Common::MonteCarlo::BaseConverter b(false);
    const unsigned long threshold = +1.5E6;

    for(unsigned long c=0; c<threshold; c++)
    {
        for( int base=2; base<=64; base++)
        {
            std::string * converted = b.baseOtherConverterTo( c, base);
            unsigned long reConverted = b.base10ConverterTo( *converted, base);
            if( reConverted != c)
            {
                std::cout<<"\n\t Allarme ! c:"<<c<<" base:"<<base<<std::endl;
            }
            else
            {
//                std::cout<<"\n\t OK ! converted: "<<*converted
//                <<" reConverted:"<<reConverted
//                <<" original:"<<c
//                <<" base:"<<base<<std::endl;
            }
            delete converted;
        }
    }

void boost_test()
{
    using namespace boost::lambda;
    typedef std::istream_iterator<int> in;

    std::for_each(
                    in(std::cin)
                    , in()
                    , std::cout << (_1 * 3) << " "
                  );
}// end boost_test



double f(double x)
{
    //return exp(x)*cos(x);
    return x*x;
}


//
//    std::string * charToString( const char par)
//    {
//        std::string * res = new std::string();
//        std::stringstream localSstream;
//        localSstream << par;//put the char into the stringStream
//        *res = localSstream.str();// get the string from the stringStream
//        // N.B. the caller has to delete the return value.
//        return res;
//    }
//


//typedef struct _GUID {
//    unsigned long  Data1;
//    unsigned short Data2;
//    unsigned short Data3;
//    unsigned char  Data4[8];
//} GUID;
//std::string * getGUID( int randInitializer)
//{
//    Common::MonteCarlo * mCarlo = new Common::MonteCarlo( randInitializer);// user suggested seed.
//    Common::StringBuilder * sb = new Common::StringBuilder(17) ;
//    for( int c=0; c<16; c++)
//    {
//        int tmp = -1;
//        while( 33>tmp || 126<tmp)
//        {
//            tmp = mCarlo->nextProbabilityMeasure() * 127;// selected code
//        }
//        sb->append( tmp);
//    }
//    delete mCarlo;
//    std::string * res = new std::string( sb->str() );// caller has to delete.
//    delete sb;
//    return res;
//}// getGUID()





namespace Common{
namespace MonteCarloNamespace{
namespace Development{

// DeltaOmega is the DeltaAscissa in a Riemann partition of the Omega Event-space.
class DeltaOmega
{// an instance of DeltaOmega is a single step in the Riemann partition. The friend function "buildOmega" builds a vector, which contains the whole population of
 // DeltaOmega, which constitutes the whole Omega event space.
private:
    friend class MonteCarloGenerator;
    double mediana;
    double eta;
    double categoryFrequency;
public:
    DeltaOmega( double medianaPoint, double etaMeasure)
    {
        this->mediana = medianaPoint;
        this->eta = etaMeasure;
        this->categoryFrequency = 0.0;// init and then add on.
    }// Ctor
    double getMediana(){return this->mediana;}
    bool belongsToDeltaOmega( double candidate)
    {
        bool res = fabs( candidate-this->mediana)<this->eta;
        return res;
    }
};// class DeltaOmega


    class MonteCarloGenerator
    {
    private:
        friend class DeltaOmega;
        bool ConstructorCanContinue;
        std::string * ReasonForAbortingConstructor;
        double theIntervalMeasure;
        double Min, Sup;
        double omothetia;
        bool leftClosed, rightClosed;
        std::vector<double> * population;
        std::vector<DeltaOmega> * frequencyDistribution;

    public:
     MonteCarloGenerator( double left, bool isLeftIncluded
                         ,double right, bool isRightIncluded
                         ,bool wantContinuousModel ):ConstructorCanContinue(true)
                         ,ReasonForAbortingConstructor(new std::string("NOT YET.") )
                         ,theIntervalMeasure(right-left)
                         ,Min(left), Sup(right)
                         ,leftClosed( isLeftIncluded), rightClosed( isRightIncluded)
                         ,population( new std::vector<double>() )
                         ,frequencyDistribution(  new std::vector<DeltaOmega>() )
         {
             //theIntervalMeasure = right-left;// init for both models; correct only for discrete ones.
             // default model is [min,sup) on [0,RAND_MAX)==[0,32767)
             if( ! wantContinuousModel)//---------------------- discrete -------------------------------------------------
             {
                 if( fabs(left-(int)left)>+1E-80
                     || fabs(right-(int)right)>+1E-80 )
                 {
                     ConstructorCanContinue = false;
                     delete this->ReasonForAbortingConstructor;//free memory of default Ctor message.
                     this->ReasonForAbortingConstructor = new std::string("Invocation of a discrete model, with non Diophantine boundaries. Aborting.");
                 }
                 else // estremi interi
                 {// non default boundary conditions.
                     if( !isLeftIncluded)
                     {
                         left += +1.0;
                         theIntervalMeasure -= +1.0;// NB. such corrections only affect the discrete case, since they have zero measure on continuous models.
                     }// else the default is already appropriate
                     if( isRightIncluded)
                     {
                         right += +1.0;
                         theIntervalMeasure += +1.0;
                     }// else the default is already appropriate
                 }// estremi interi
             }////-------END--------------- discrete -------------------------------------------------
             this->omothetia = this->theIntervalMeasure/((double)RAND_MAX);
             //
         }// Ctor

        void nextIntegerInInterval() const
        {
            double temp =  rand()*this->omothetia+this->Min;
            this->population->push_back( (int)temp);
        }// END nextIntegerInInterval

        void nextDoubleInInterval() const
        {
            double temp = rand()*this->omothetia+this->Min;
            if( this->rightClosed)
            {
                while( temp>this->Sup)
                {
                    temp = rand()*this->omothetia+this->Min;
                }
            }
            this->population->push_back( temp);
        }// END nextIntegerInInterval

        void showPopulation() const
        {
            for( std::vector<double>::const_iterator it=this->population->begin();
                 it!=this->population->end();
                 it++
                )
                {
                    std::cout<< *it<<std::endl;
                }
        }// END showPopulation() const

        void showFrequencyDistribution() const
        {
            for( std::vector<DeltaOmega>::const_iterator it=this->frequencyDistribution->begin();
                 it!=this->frequencyDistribution->end();
                 it++
                )
                {

                        double mediana;
                        double eta;
                        double categoryFrequency;

                    std::cout<<" mediana "<< *Common::StrManipul::doubleToString(it->mediana)<<" eta "
                    << *Common::StrManipul::doubleToString(it->eta)
                    <<" categoryFrequency "<<*Common::StrManipul::doubleToString(it->categoryFrequency) <<std::endl;
                }
        }// END showFrequencyDistribution() const

        void showCumulatedFrequency() const
        {
           double CumulatedFrequency = 0.0;
           for( std::vector<DeltaOmega>::iterator frequencyWriter=this->frequencyDistribution->begin();
                frequencyWriter != this->frequencyDistribution->end();
                frequencyWriter++
              )
              {
                 CumulatedFrequency += frequencyWriter->categoryFrequency;
              }// for frequencyWriter
              std::cout<< "\n\n\t CumulatedFrequency : " << CumulatedFrequency <<std::endl;
        }// END showCumulatedFrequency() const


        void buildFrequencyDistribution()
        {
            int populationCardinality = this->population->size();
            double elementPresenceWeight = +1.0/populationCardinality;
            for( std::vector<double>::const_iterator populationReader=this->population->begin();
                 populationReader != this->population->end();
                 populationReader++
               )
               {
                   for( std::vector<DeltaOmega>::iterator frequencyWriter=this->frequencyDistribution->begin();
                        frequencyWriter != this->frequencyDistribution->end();
                        frequencyWriter++
                      )
                      {
                          if( frequencyWriter->belongsToDeltaOmega( *populationReader) )
                          {
                              frequencyWriter->categoryFrequency += elementPresenceWeight;
                              break;// belonging class found.
                          }
                      }// for frequencyWriter

               }// for populationReader
        }// buildFrequencyDistribution()



        void buildOmega( double partizioneLeft
                         ,double partizioneRight
                         ,double eta
                       )
        {//this->frequencyDistribution has been built by Ctor.
            for( double position=partizioneLeft-eta; position<=partizioneRight+eta; position+=2*eta)
            {
                DeltaOmega * curDeltaOmega = new DeltaOmega( position+eta, eta);// TODO verify
                this->frequencyDistribution->push_back( *curDeltaOmega );
            }//for
        }//buildOmega



    };// class MonteCarloGenerator


std::string * exadecimalConverterTo( unsigned int par )
{
    const std::string exaFigures("0123456789ABCDEF");
    Common::StringBuilder sb(20);
    sb.append("0x");//start with Hex prefix.
    int abacusLeftMostPosition = log(par)/log(16);
    double dividendo = (double)par;
    for( ;abacusLeftMostPosition>=0; abacusLeftMostPosition--)
    {
        double quotient = dividendo/ pow(+16.0,(double)abacusLeftMostPosition);
        double resto = dividendo - ((int)quotient)*pow(+16.0,(double)abacusLeftMostPosition);
        // update
        sb.append( exaFigures[(int)quotient]);
        dividendo = resto;
    }
    //ready.
    std::string * res = new std::string( sb.str());
    return res;// caller has to delete.
}

std::string * base64ConverterTo( unsigned int par )
{

        [48,57]
        [65,90]
        [97,126]

    Common::StringBuilder sbB4symbols( 66);
    for( int c=48;c<=57;c++)// figures
    {//NB. append(int) appende alla stringa il simbolo corrispondente al codice int.
        sbB4symbols.append(c);
    }
    for( int c=65;c<=90;c++)
    {// upper case letters
        sbB4symbols.append(c);
    }
    for( int c=97;c<=126;c++)
    {// lower case letters + some symbols
        sbB4symbols.append(c);
    }

    std::string base64Figures( sbB4symbols.str() );
    std::cout<< base64Figures<<std::endl;



    Common::StringBuilder sb( 100);
    sb.append("b64_");//start with base64 prefix.
    int abacusLeftMostPosition = log(par)/log(64);
    double dividendo = (double)par;
    for( ;abacusLeftMostPosition>=0; abacusLeftMostPosition--)
    {
        double quotient = dividendo/ pow(+64.0,(double)abacusLeftMostPosition);
        double resto = dividendo - ((int)quotient)*pow(+64.0,(double)abacusLeftMostPosition);
        // update
        sb.append( base64Figures[(int)quotient]);
        dividendo = resto;
    }
    //ready.
    std::string * res = new std::string( sb.str());
    return res;// caller has to delete.
}

unsigned long base10ConverterTo( const std::string & base64par )
{

        [48,57]
        [65,90]
        [97,126]

    Common::StringBuilder sbB4symbols( 66);
    for( int c=48;c<=57;c++)// figures
    {//NB. append(int) appende alla stringa il simbolo corrispondente al codice int.
        sbB4symbols.append(c);
    }
    for( int c=65;c<=90;c++)
    {// upper case letters
        sbB4symbols.append(c);
    }
    for( int c=97;c<=126;c++)
    {// lower case letters + some symbols
        sbB4symbols.append(c);
    }

    std::string base64Figures( sbB4symbols.str() );
    std::map<char,int> * base64Map = new std::map<char,int>();
    for( int c=0; c<base64Figures.size(); c++)
    {
        (*base64Map)[base64Figures[c]]= c;
    }

    for( std::map<char,int>::const_iterator reader=base64Map->begin();
         reader != base64Map->end();
         reader++ )
         {
             std::cout<< (*reader).first<<"  "<< (*reader).second<<std::endl;
         }

    unsigned long decimalQuantity = 0;// init and sum on it.
    std::string * cleanVersion = Common::StrManipul::replaceAllOccurencesOf("b64_",base64par,"");
    int abacusLeftMostPosition = cleanVersion->size()-1;// zero based
    for( int c=0 ;abacusLeftMostPosition>=0; abacusLeftMostPosition--,c++)
    {
        unsigned long figureQuantity = (*base64Map)[ (*cleanVersion)[c]];// value of the symbol.
        double abacusPositionQuantity = pow( +64.0 , (double)abacusLeftMostPosition );
        figureQuantity *= abacusPositionQuantity;
        decimalQuantity += figureQuantity;
    }
    delete cleanVersion;
    //ready.
    return decimalQuantity;
}

}// Development
}// MonteCarloNamespace
}// Common


    std::string * converted =
    Common::MonteCarloNamespace::Development::base64ConverterTo( 4294967295);// max(unsigned long)
    std::cout<<"dec 64 == B64 "<< *converted<<std::endl;

    unsigned long backFromB64 =// NB. avoid backSlashes due to escape sequences.
     Common::MonteCarloNamespace::Development::base10ConverterTo( *converted);
    delete converted;

    converted =
    Common::MonteCarloNamespace::Development::base64ConverterTo( backFromB64);
    std::cout<<"dec 64 == B64 "<< *converted<<std::endl;

    converted =
     Common::MonteCarloNamespace::Development::exadecimalConverterTo( 9898798);
    std::cout<<"dec 9898798 == B16 "<< *converted<<std::endl;
    delete converted;

    std::cout<<"sizeof(unsigned long) : "<<sizeof(unsigned long)<<std::endl;
    std::cout<<"sizeof(unsigned short) : "<<sizeof(unsigned short)<<std::endl;
    std::cout<<"sizeof(unsigned char) : "<<sizeof(unsigned char)<<std::endl;
//    unsigned long  Data1;  4 bytes == 32bit
//    unsigned short Data2;  2 == 16bit
//    unsigned short Data3;  2
//    unsigned char  Data4[8]; 1x8 == 64bit

//    int input =0;
//    for(;;)
//    {
//        std::cout << "Enter decimal number: " ;
//        std::cin >> input ;
//        if( 0 > input) {break;}
//        std::cout << "0x" << std::hex << input << '\n' ;
//    }



    double left  = +2.0;
    double right = +5.0;
    int populationCardinality = 4;
    double eta = +0.5;
    //
    Common::MonteCarloNamespace::Development::MonteCarloGenerator * monteCGen =
    new Common::MonteCarloNamespace::Development::MonteCarloGenerator(
                        left,true
                        ,right,true
                        ,true // is_continuous
                         );
    for( int c=0; c<populationCardinality;c++)
    {
        //monteCGen->nextIntegerInInterval();
        monteCGen->nextDoubleInInterval();
    }
    monteCGen->showPopulation();
    monteCGen->buildOmega( left, right, eta);
    monteCGen->buildFrequencyDistribution();
    monteCGen->showFrequencyDistribution();
    monteCGen->showCumulatedFrequency();

    delete monteCGen;

    //Common::Stream::showASCII();

//    for( int c=32; c<127; c++)
//    {
//        std::string * strASCIIcode = Common::StrManipul::intToString( c);
//        std::string * strASCIIsymb = Common::StrManipul::charToString( c);
//        //
//        std::cout<< " ASCII code "+ *strASCIIcode
//        + " corresponds to symbol : "
//        + *strASCIIsymb
//        << std::endl;
//        //
//        delete strASCIIcode;// free at each step, the allocated memory.
//        delete strASCIIsymb;
//    }// for


//    Common::dbCall::cantiere_numericTable_INSERT_SINGLE( -5.67005 );
//    Common::dbCall::cantiere_sede_INSERT_SINGLE();
//    Common::dbCall::cantiere_sede_LOAD_MULTI_();


//    boost_test();

    // Common::command_PREPARE(); tested : hangs with noexcept.

//    Entity::Integration::rettangoli( +100.0,
//                                     +120.0,
//                                     28,
//                                     f
//                                     , false // i.e. not called from inside "trapezi"
//                                     );
//
//    Entity::Integration::trapezi( +100.0,
//                                     +120.0,
//                                     28,
//                                     f
//                                     );

    // sqlParameters();
    //preparedStatement();
//    Process::testCpp11_MonteCarlo();



//    Common::MonteCarlo * mcInitializer = new Common::MonteCarlo();// time based seed.
//    int min = +2;
//    int sup = +4;
//    std::string * minStr = Common::StrManipul::intToString( min);
//    std::string * maxStr = Common::StrManipul::intToString( sup-1);
//    for( int c=0; c<20; c++)
//    {
//        std::string * tmp = Common::StrManipul::intToString(mcInitializer->nextIntegerInInterval( min, sup));
//        std::cout<< "int in ["+ *minStr +", "+ *maxStr +"] : " + *tmp <<std::endl;
//        delete tmp;
//    }
//    delete minStr;
//    delete maxStr;
//    delete mcInitializer;

Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.

The MySQL Connector/C++ is licensed under the terms of the GPLv2
<http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
MySQL Connectors. There are special exceptions to the terms and
conditions of the GPLv2 as it is applied to this software, see the
FLOSS License Exception
<http://www.mysql.com/about/legal/licensing/foss-exception.html>.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

//
//
///**
//* Example of statements - not to be confused with prepared statements
//*
//* NOTE: The MySQL Server does not support each and every SQL statement
//* to be prepared. The list of statements which can be prepared is available
//* in the MySQL Server documentation and the C API documentation:
//* http://dev.mysql.com/doc/refman/5.1/en/c-api-prepared-statements.html
//* (Link to the MySQL Server 5.1 documentation!)
//*
//* Connector/C++ is based on the C API and C library "libmysql". Therefore
//* it inherits all limitations from the MySQL Server and the MySQL C API.
//*
//* MySQL 5.1.12 can prepare the following statements:
//*
//* - CREATE TABLE, DELETE, DO, INSERT, REPLACE, SELECT, SET, UPDATE
//* - most SHOW commands
//* - ANALYZE TABLE, OPTIMIZE TABLE, REPAIR TABLE
//* - CACHE INDEX, CHANGE MASTER, CHECKSUM {TABLE | TABLES},
//* - {CREATE | RENAME | DROP} DATABASE, {CREATE | RENAME | DROP} USER
//* - FLUSH {TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES | LOGS | STATUS | MASTER | SLAVE | DES_KEY_FILE | USER_RESOURCES}
//* - GRANT, REVOKE, KILL, LOAD INDEX INTO CACHE, RESET {MASTER | SLAVE | QUERY CACHE}
//* - SHOW BINLOG EVENTS, SHOW CREATE {PROCEDURE | FUNCTION | EVENT | TABLE | VIEW}
//* - SHOW {AUTHORS | CONTRIBUTORS | WARNINGS | ERRORS}
//* - SHOW {MASTER | BINARY} LOGS, SHOW {MASTER | SLAVE} STATUS
//* - SLAVE {START | STOP}, INSTALL PLUGIN, UNINSTALL PLUGIN
//*
//*  ... that's pretty much every *core* SQL statement - but not USE as you'll see below.
//*
//* Connector/C++ does not include a prepared statement emulation
//*
//* @link http://dev.mysql.com/doc/refman/5.1/en/c-api-prepared-statements.html
//*/
//
///* Standard C++ includes */
//#include <stdlib.h>
//#include <iostream>
//#include <sstream>
//#include <stdexcept>
//
///*
//  Public interface of the MySQL Connector/C++.
//  You might not use it but directly include directly the different
//  headers from cppconn/ and mysql_driver.h + mysql_util.h
//  (and mysql_connection.h). This will reduce your build time!
//*/
//#include <driver/mysql_public_iface.h>
///* Connection parameter and sample data */
//#include "examples.h"
//
//bool prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql);
//sql::Statement* emulate_prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql);
//
//using namespace std;
//
//int prepareExample(int argc, const char **argv)
//{
//	static const string url(argc >= 2 ? argv[1] : EXAMPLE_HOST);
//	static const string user(argc >= 3 ? argv[2] : EXAMPLE_USER);
//	static const string pass(argc >= 4 ? argv[3] : EXAMPLE_PASS);
//	static const string database(argc >= 5 ? argv[4] : EXAMPLE_DB);
//
//	/* Driver Manager */
//	sql::Driver *driver;
//	/* sql::ResultSet.rowsCount() returns size_t */
//	size_t row;
//	stringstream sql;
//	stringstream msg;
//	int i, num_rows;
//
//	cout << boolalpha;
//	cout << "1..1" << endl;;
//	cout << "# Connector/C++ prepared statement example.." << endl;
//
//	try {
//		/* Using the Driver to create a connection */
//		driver = sql::mysql::get_driver_instance();
//		std::auto_ptr< sql::Connection > con(driver->connect(url, user, pass));
//
//		/* The usage of USE is not supported by the prepared statement protocol */
//		std::auto_ptr< sql::Statement > stmt(con->createStatement());
//		stmt->execute("USE " + database);
//
//		/*
//		Prepared statement are unhandy for queries which you execute only once!
//
//		prepare() will send your SQL statement to the server. The server
//		will do a SQL syntax check, perform some static rewriting like eliminating
//		dead expressions such as "WHERE 1=1" and simplify expressions
//		like "WHERE a > 1 AND a > 2" to "WHERE a > 2". Then control gets back
//		to the client and the server waits for execute() (or close()).
//		On execute() another round trip to the server is done.
//
//		In case you execute your prepared statement only once - like shown below -
//		you get two round trips. But using "simple" statements - like above - means
//		only one round trip.
//
//		Therefore, the below is *bad* style. WARNING: Although its *bad* style,
//		the example program will continue to do it to demonstrate the (ab)use of
//		prepared statements (and to prove that you really can do more than SELECT with PS).
//		*/
//		std::auto_ptr< sql::PreparedStatement > prep_stmt(con->prepareStatement("DROP TABLE IF EXISTS test"));
//		prep_stmt->execute();
//
//		prepare_execute(con, "CREATE TABLE test(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, label CHAR(1))");
//		cout << "#\t Test table created" << endl;
//
//		/*
//		The first useful example - prepare() once, execute() n + 1 times
//		NOTE: The MySQL Server does not support named parameters. You have to use
//		the placeholder syntax shown below. There is no emulation which would you
//		allow to use named parameter like ':param1'. Use '?'. Parameters are 1-based.
//		*/
//		num_rows = 0;
//		prep_stmt.reset(con->prepareStatement("INSERT INTO test(id, label) VALUES (?, ?)"));
//		for (i = 0; i < EXAMPLE_NUM_TEST_ROWS; i++) {
//			prep_stmt->setInt(1, test_data[i].id);
//			prep_stmt->setString(2, test_data[i].label);
//			/* executeUpdate() returns the number of affected = inserted rows */
//			num_rows += prep_stmt->executeUpdate();
//		}
//
//		if (EXAMPLE_NUM_TEST_ROWS != num_rows) {
//			msg.str("");
//			msg << "Expecting " << EXAMPLE_NUM_TEST_ROWS << "rows, reported " << num_rows;
//			throw runtime_error(msg.str());
//		}
//		cout << "#\t Test table populated" << endl;
//
//		/* We will reuse the SELECT a bit later... */
//		std::auto_ptr< sql::PreparedStatement > prep_select(con->prepareStatement("SELECT id, label FROM test ORDER BY id ASC"));
//		cout << "#\t Running 'SELECT id, label FROM test ORDER BY id ASC'" << endl;
//		std::auto_ptr< sql::ResultSet > res(prep_select->executeQuery());
//		row = 0;
//		while (res->next()) {
//			cout << "#\t\t Row " << row << " - id = " << res->getInt("id");
//			cout << ", label = '" << res->getString("label") << "'" << endl;
//			row++;
//		}
//		res.reset(NULL);
//
//		if (EXAMPLE_NUM_TEST_ROWS != row) {
//			msg.str("");
//			msg << "Expecting " << EXAMPLE_NUM_TEST_ROWS << "rows, reported " << row;
//			throw runtime_error(msg.str());
//		}
//
//		cout << "#\t Simple PS 'emulation' for USE and another SELECT" << endl;
//		stmt.reset(emulate_prepare_execute(con, string("USE " + database).c_str()));
//		stmt.reset(emulate_prepare_execute(con, string("USE " + database).c_str()));
//
//		stmt.reset(emulate_prepare_execute(con, "SELECT id FROM test ORDER BY id ASC"));
//		res.reset(stmt->getResultSet());
//		if (res.get() != NULL) {
//			row = 0;
//			while (res->next()) {
//				cout << "#\t\t Row " << row << " - id = " << res->getInt("id") << endl;
//				row++;
//			}
//			res.reset(NULL);
//		}
//		stmt.reset(NULL);
//
//		/* Running the SELECT again but fetching in reverse order */
//		cout << "#\t SELECT and fetching in reverse order" << endl;
//
//		res.reset(prep_select->executeQuery());
//		row = res->rowsCount();
//		cout << "#\t\t res->getRowsCount() = " << res->rowsCount() << endl;
//		if (res->rowsCount() != EXAMPLE_NUM_TEST_ROWS) {
//			msg.str("");
//			msg << "Expecting " << EXAMPLE_NUM_TEST_ROWS << "rows, found " << res->rowsCount();
//			throw runtime_error(msg.str());
//		}
//
//		/* Position the cursor after the last row */
//		cout << "#\t\t Position the cursor after the last row\n";
//		res->afterLast();
//		cout << "#\t\t res->isafterLast()\t= " << res->isAfterLast() << endl;
//		cout << "#\t\t res->isLast()\t\t= " << res->isLast() << endl;
//		if (!res->isAfterLast() || res->isLast())
//			throw runtime_error("Moving the cursor after the last row failed");
//
//		while (res->previous()) {
//			cout << "#\t\t res->previous()\n";
//			cout << "#\t\t Row " << row << " - id = " << res->getInt("id");
//			cout << ", label = '" << res->getString("label") << "'" << endl;
//			row--;
//		}
//		cout << "#\t\t Should be before the first\n";
//		cout << "#\t\t res->isFirst()\t\t= " << res->isFirst() << endl;
//		cout << "#\t\t res->isBeforeFirst()\t= " << res->isBeforeFirst() << endl;
//		if (res->isFirst() || !res->isBeforeFirst())
//			throw runtime_error("Cursor should be before first row");
//
//		/* Now that the cursor is before the first, fetch the first */
//		cout << "#\t\t Now that the cursor is before the first, fetch the first\n";
//		cout << "#\t\t calling next() to fetch first row" << endl;
//		row++;
//		res->next();
//		cout << "#\t\t res->isFirst()\t\t= " << res->isFirst() << endl;
//		cout << "#\t\t Row " << row << " - id = " << res->getInt("id");
//		cout << ", label = '" << res->getString("label") << "'" << endl;
//		row--;
//
//		/* For more on cursors see resultset.cpp example */
//
//		/* Clean up */
//		res.reset(NULL);
//		stmt.reset(con->createStatement());
//		stmt->execute("DROP TABLE IF EXISTS test");
//		cout << "#done!" << endl;
//
//	} catch (sql::SQLException &e) {
//		/*
//		The MySQL Connector/C++ throws three different exceptions:
//
//		- sql::MethodNotImplementedException (derived from sql::SQLException)
//		- sql::InvalidArgumentException (derived from sql::SQLException)
//		- sql::SQLException (derived from std::runtime_error)
//		*/
//		cout << endl;
//		cout << "# ERR: DbcException in " << __FILE__;
//		cout << "(" << EXAMPLE_FUNCTION << ") on line " << __LINE__ << endl;
//		/* Use what(), getErrorCode() and getSQLState() */
//		cout << "# ERR: " << e.what();
//		cout << " (MySQL error code: " << e.getErrorCode();
//		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//
//		if (e.getErrorCode() == 1047) {
//			/*
//			Error: 1047 SQLSTATE: 08S01 (ER_UNKNOWN_COM_ERROR)
//			Message: Unknown command
//			*/
//			cout << "# ERR: Your server seems not to support PS at all because its MYSQL <4.1" << endl;
//		}
//		cout << "not ok 1 - examples/prepared_statement.cpp" << endl;
//
//		return EXIT_FAILURE;
//	} catch (std::runtime_error &e) {
//
//		cout << endl;
//		cout << "# ERR: runtime_error in " << __FILE__;
//		cout << "(" << EXAMPLE_FUNCTION << ") on line " << __LINE__ << endl;
//		cout << "# ERR: " << e.what() << endl;
//		cout << "not ok 1 - examples/prepared_statement.cpp" << endl;
//
//		return EXIT_FAILURE;
//	}
//
//	cout << "ok 1 - examples/prepared_statement.cpp" << endl;
//	return EXIT_SUCCESS;
//}
//
//
//bool prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql)
//{
//	sql::PreparedStatement * prep_stmt;
//
//	prep_stmt = con->prepareStatement(sql);
//	prep_stmt->execute();
//	delete prep_stmt;
//
//	return true;
//}
//
//
//sql::Statement* emulate_prepare_execute(std::auto_ptr< sql::Connection > & con, const char *sql)
//{
//	sql::PreparedStatement *prep_stmt;
//	sql::Statement *stmt = NULL;
//
//	cout << "#\t\t 'emulation': " << sql << endl;
//
//	try {
//
//		prep_stmt = con->prepareStatement(sql);
//		prep_stmt->execute();
//		cout << "#\t\t 'emulation': use of sql::PreparedStatement possible" << endl;
//		/* safe upcast - PreparedStatement is derived from Statement */
//		stmt = prep_stmt;
//
//	} catch (sql::SQLException &e) {
//		/*
//		Maybe the command is not supported by the MySQL Server?
//
//		http://dev.mysql.com/doc/refman/5.1/en/error-messages-server.html
//		Error: 1295 SQLSTATE: HY000 (ER_UNSUPPORTED_PS)
//
//		Message: This command is not supported in the prepared statement protocol yet
//		*/
//
//		if (e.getErrorCode() != 1295) {
//			// The MySQL Server should be able to prepare the statement
//			// but something went wrong. Let the caller handle the error.
//			throw ;
//		}
//		cout << "#\t\t 'emulation': ER_UNSUPPORTED_PS and fallback to sql::Statement" << endl;
//		cout << "#\t\t ERR: " << e.what();
//		cout << " (MySQL error code: " << e.getErrorCode();
//		cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//
//		stmt = con->createStatement();
//		stmt->execute(sql);
//	}
//
//	return stmt;
//}

void sqlParameters()
{
    sql::Driver *driver;
    sql::Connection *con;
    sql::PreparedStatement *prep_stmt = nullptr;
    //
    driver = get_driver_instance();// get the driver
    con = driver->connect("tcp://127.0.0.1:3306", "root", "Riemann0");
    //
    sql::SQLString * mySqlString = new sql::SQLString("cantiere");
    prep_stmt = con->prepareStatement( "INSERT INTO cantiere.sede(Baustelle_name, role, set_by) VALUES ( ?, ?, ?)");
    //
    //--preparing for first usage:
    prep_stmt->setString(1, "nomeCantiere_uno");
    prep_stmt->setString(2, "ruoloSede_uno");
    prep_stmt->setString(3, "collaboratoreSottoscrittore_uno");
    prep_stmt->execute();//-- first usage.
    //
    //--preparing for second usage:
    prep_stmt->setString(1, "nomeCantiere_due");
    prep_stmt->setString(2, "ruoloSede_due");
    prep_stmt->setString(3, "collaboratoreSottoscrittore_due");
    prep_stmt->execute();//-- second usage.
    //
    // ready : clean up now.
//    delete prep_stmt;
    delete con;
}// end sqlParameters()



void preparedStatement()
{
cout << endl;
cout << "Let's have MySQL count from 10 to 1..." << endl;

try {
  sql::Driver *driver;
  sql::Connection *con;
  sql::Statement *stmt;
  sql::ResultSet *res;
  sql::PreparedStatement *pstmt;

  //  Create a connection
  driver = get_driver_instance();
  con = driver->connect("tcp://127.0.0.1:3306", "root", "Riemann0");
  // Connect to the MySQL test database
//con->setSchema("test");

  stmt = con->createStatement();
  stmt->execute("DROP TABLE IF EXISTS cantiere.test");
  stmt->execute("CREATE TABLE cantiere.test(id INT)");
  delete stmt;

  /* '?' is the supported placeholder syntax */
  pstmt = con->prepareStatement("INSERT INTO cantiere.test(id) VALUES (?)");
  for (int i = 1; i <= 10; i++) {
    pstmt->setInt(1, i);
    pstmt->executeUpdate();
  }
  delete pstmt;

  /* Select in ascending order */
  pstmt = con->prepareStatement("SELECT id FROM test ORDER BY id ASC");
  res = pstmt->executeQuery();

  /* Fetch in reverse = descending order! */
  res->afterLast();
  while (res->previous())
    cout << "\t... MySQL counts: " << res->getInt("id") << endl;
  delete res;

  delete pstmt;
  delete con;

} catch (sql::SQLException &e) {
  cout << "# ERR: SQLException in " << __FILE__;
  cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
  cout << "# ERR: " << e.what();
  cout << " (MySQL error code: " << e.getErrorCode();
  cout << ", SQLState: " << e.getSQLState() << " )" << endl;
}

cout << endl;
}

//
//int OracleSuggests()
//{
//    cout << endl;
//    cout << "Running 'SELECT 'Hello World!' AS _message'..." << endl;
//
//    try
//    {
//        sql::Driver *driver;
//        sql::Connection *con;
//        sql::Statement *stmt;
//        sql::ResultSet *res;
//
//        // Create a connection : steps follow:
//        driver = get_driver_instance();// get the driver
//        con = driver->connect( "tcp://127.0.0.1:3306", "root", "Riemann0");// get the connection to the specified instance.
//        //con = driver->connect( "tcp://Eulero:3306", "root", "Riemann0");// get the connection to the specified instance.
//        // con->setAutoCommit( false);
//        //con->setAutoCommit( true);
//        //con->setSchema("cantiere");// choose which database, within the instance.
//        //
//        // execute something, with the current connection:
//        stmt = con->createStatement();// prepare a statement
//        res = stmt->executeQuery("SELECT 'Hello World!' AS _message");// execute the statement
//        //
//        //-------fetch the resultset--------------------
//        while (res->next())
//        {
//            cout << "\t... MySQL replies: ";
//            // Access column data by alias or column name
//            cout << res->getString("_message") << endl;
//            cout << "\t... MySQL says it again: ";
//            // Access column data by numeric offset, 1 is the first column
//            cout << res->getString(1) << endl;
//        }//--END-----fetch the resultset--------------------
//        //--- cleanup------
//        delete res;
//        delete stmt;
//        delete con;
//    }// END try
//    catch( sql::SQLException &e)
//    {
//        cout << "# ERR: SQLException in " << __FILE__;
//        cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
//        cout << "# ERR: " << e.what();
//        cout << " (MySQL error code: " << e.getErrorCode();
//        cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//    }// END catch( sql::SQLException &e)
//    catch( const std::exception& ex)
//    {
//        std::string HappenedException = ex.what();
//    }
//    catch (const std::string& ex)
//    {
//        std::string HappenedException = ex.c_str();
//    }
//    catch(...)
//    {
//        std::string HappenedException = "this was (sadly) an unnamed exception, which -therefore- has no content.";
//    }// END catch(...)
//
//    // ready.
//    cout << endl;
//    getchar();
//    return EXIT_SUCCESS;
//}// end OracleSuggests.
//
//
//
//
//int cantiere_sede_SELECT_MULTI_(void)
//{
//    cout << endl;
//    cout << " cantiere_sede_SELECT_MULTI_ : " << endl;
//    int rowCard  = 0;
//
//    try
//    {
//        sql::Driver *driver;
//        sql::Connection *con;
//        sql::Statement *stmt;
//        sql::ResultSet *res;
//
//        // Create a connection : steps follow:
//        driver = get_driver_instance();// get the driver
//        con = driver->connect( "tcp://127.0.0.1:3306", "root", "Riemann0");// get the connection to the specified instance.
//        //con = driver->connect( "tcp://Eulero:3306", "root", "Riemann0");// get the connection to the specified instance.
//        // con->setAutoCommit( false);
//        //con->setAutoCommit( true);
//        //con->setSchema("cantiere");// choose which database, within the instance.
//        //
//        // execute something, with the current connection:
//        stmt = con->createStatement();// prepare a statement
////res = stmt->executeQuery("SELECT * from cantiere.sede");// execute the statement
//        res = stmt->executeQuery("call cantiere.usp_SEDE_LOAD_MULTI");// execute the statement
//        //
//        //-------fetch the resultset--------------------
//        while( res->next() )
//        {
//            cout << "\t... MySQL replies: ";
//            cout << res->getString("id") << "   ";// Access column data by alias or column name
//            cout << res->getString("Baustelle_name") << "   ";// Access column data by alias or column name
//            cout << res->getString("role") << "   ";// Access column data by alias or column name
//            cout << res->getString("set_time") << "   ";// Access column data by alias or column name
//            cout << res->getString("set_by") << endl;// Access column data by alias or column name // NewLine on end of Record (which is a table's line).
//            //cout << res->getString(1) << endl;// Access column data by numeric offset, 1 is the first column
//            ++rowCard;// done a line.
//        }//--END-----fetch the resultset--------------------
//        //
//        std::cout << "\n\n\t Processed lines # " << rowCard << std::endl;
//        //--- cleanup------
//        delete res;
//        delete stmt;
//        if( ! con->isClosed() )
//        {
//            con->close();
//        }// else already closed.
//        delete con;
//    }// END try
//    catch( sql::SQLException &e)
//    {
//        cout << "# ERR: SQLException in " << __FILE__;
//        cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
//        cout << "# ERR: " << e.what();
//        cout << " (MySQL error code: " << e.getErrorCode();
//        cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//    }// END catch( sql::SQLException &e)
//    catch( const std::exception& ex)
//    {
//        std::string HappenedException = ex.what();
//    }
//    catch (const std::string& ex)
//    {
//        std::string HappenedException = ex.c_str();
//    }
//    catch(...)
//    {
//        std::string HappenedException = "this was (sadly) an unnamed exception, which -therefore- has no content.";
//    }// END catch(...)
//
//    // ready.
//    cout << endl;
//    return rowCard;
//}// end cantiere_sede_SELECT_MULTI_
//
//
//
//
//int cantiere_sede_INSERT_SINGLE(void)
//{
//    cout << endl;
//    cout << " cantiere_sede_INSERT_SINGLE : " << endl;
//    bool insertionHasError;// insertion result
//
//    try
//    {
//        sql::Driver *driver;
//        sql::Connection *con;
//        sql::Statement *stmt;
//
//        // Create a connection : steps follow:
//        driver = get_driver_instance();// get the driver
//        con = driver->connect( "tcp://127.0.0.1:3306", "root", "Riemann0");// get the connection to the specified instance.
//        //
//        // execute something, with the current connection:
//        stmt = con->createStatement();// prepare a statement
//        const std::string theStatement = "call cantiere.usp_SEDE_INSERT_SINGLE ('sixth_fromCPP','sixth_fromCPP','sixth_fromCPP')";
////con->
////stmt->
////driver->
//        insertionHasError = stmt->execute( theStatement);// execute the statement
//        //
//        //--- cleanup------
//        delete stmt;
//        if( ! con->isClosed() )
//        {
//            con->close();
//        }// else already closed.
//        delete con;
//    }// END try
//    catch( sql::SQLException &e)
//    {
//        cout << "# ERR: SQLException in " << __FILE__;
//        cout << "(" << __FUNCTION__ << ") on line " << __LINE__ << endl;
//        cout << "# ERR: " << e.what();
//        cout << " (MySQL error code: " << e.getErrorCode();
//        cout << ", SQLState: " << e.getSQLState() << " )" << endl;
//    }// END catch( sql::SQLException &e)
//    catch( const std::exception& ex)
//    {
//        std::string HappenedException = ex.what();
//    }
//    catch (const std::string& ex)
//    {
//        std::string HappenedException = ex.c_str();
//    }
//    catch(...)
//    {
//        std::string HappenedException = "this was (sadly) an unnamed exception, which -therefore- has no content.";
//    }// END catch(...)
//
//    // ready.
//    cout << endl;
//    return insertionHasError;// false on insertionSuccess( 1 row i.e. INSERT_SINGLE), ture on error.
//}// end cantiere_sede_INSERT_SINGLE



//class HandledProto
//{
//private:
//    int * handledData;
//    const int dataCard = 16;
//
//public:
//    HandledProto()
//    {
//        handledData = (int *)new int[dataCard];
//        for(int c=0; c<dataCard; c++)
//        {
//            handledData[c] = c;
//        }
//    }
//
//    HandledProto( const HandledProto &other)
//    {
//        this->handledData = other.handledData;
//    }
//
//    /*
//    HandledProto( HandledProto &&ancestor)
//    {
//        this->handledData = std::move( ancestor);
//    }*/
//};
//
//
//void testExcept()
//{
//    try
//    {
//        int i=5;
//        ++i;
//        throw i;
//    }
//    catch(int i)
//    {
//        std::cout << "caught " << i << std::endl;
//    }
//    catch(...)
//    {
//        std::cout << "caught generic exception." << std::endl;
//    }
//}


//    std::string original = "Nel mezzo #f# #f# #f#  #f# del cammin #f# di nostra vita #f# #f# mi ritrovai per una selva oscura #f# #f# #f#.";
//    std::cout << "original = ";
//    std::cout << original << std::endl;
//
//    std::string * tmp = Common::StrManipul::replaceAllOccurencesOf("#f#",
//        original,
//        "_thisWasAToken_" );
//    std::cout << "after replacement = " << *tmp << std::endl;
//    delete tmp;
//    std::cout << "original = ";
//    std::cout << original << std::endl;
//
//    std::vector<std::string> * theDirtyTokens = Common::StrManipul::stringSplit(
//     "#f#", "Nel mezzo #f# #f# #f#  #f# del cammin #f# di nostra vita #f# #f# mi ritrovai per una selva oscura #f# #f# #f#.",
//     false);
//    for( std::vector<std::string>::iterator it=theDirtyTokens->begin();
//         it != theDirtyTokens->end();
//         it++
//    )
//    {
//        std::cout << *it << std::endl;
//    }
//    delete theDirtyTokens;
//    //
//    std::cout << "\n\n" << std::endl;
//    std::vector<std::string> * theTokens = Common::StrManipul::stringSplit(
//     "#f#", "Nel mezzo #f# #f# #f#  #f# del cammin #f# di nostra vita #f# #f# mi ritrovai per una selva oscura #f# #f# #f#.",
//     true);
//    for( std::vector<std::string>::iterator it=theTokens->begin();
//         it != theTokens->end();
//         it++
//    )
//    {
//        std::cout << Common::StrManipul::trimBoth( *it) << std::endl;
//    }
//    delete theTokens;
//
//
//    // testExcept();
//
//    Process::testMonteCarlo();



//
//    TestSplit::MemCaleeCaller * m = new TestSplit::MemCaleeCaller();
//    std::vector<std::string> * res = m->stringSplit_withAllocation("#","Nel # mezzo # del # cammin", false);
//    for( std::vector<std::string>::iterator it=res->begin(); it!=res->end(); it++)
//    {
//        std::cout << *it << "\n";
//    }
//    //--------------------
//    std::cout << "\n\n\n";
//    std::vector<std::string> * IOres = new std::vector<std::string>();
//    m->stringSplit_withoutAlloc("#","Nel # mezzo # del # cammin", *IOres, false);
//    for( std::vector<std::string>::iterator it=IOres->begin(); it!=IOres->end(); it++)
//    {
//        std::cout << *it << "\n";
//    }
//    //
//    delete res;
//    delete IOres;
//    delete m;
//
//    logTest_monothread_();// mono_thread.
//    //
//    int nThreads = 3;
//    std::thread threads[nThreads];
//    // spawn nThreads threads:
//    for (int i=0; i<nThreads; ++i)
//    {
//        threads[i] = std::thread(EntryPointThreadSpawn_TraceOnly_, i+1);
//    }
//    //
//    for (auto& th : threads)
//    {
//        th.join();
//    }
//

//
//    configFileTestGenerator();
//
//    Common::ConfigurationService * cs = Process::getDefaultConfiguration();// AppConfig.txt
//    if( nullptr == cs)
//    {
//        return -1;
//    }
//    std::vector<std::string> * theKeys = cs->getAllKeys();
//    int ckey=0;
//    for( std::vector<std::string>::iterator keysIter=theKeys->begin(); keysIter!=theKeys->end(); keysIter++)
//    {
//        std::cout<<" chiave nr. "<< ++ckey <<"  "<< (*keysIter).c_str() << std::endl;
//    }
//    theKeys->clear();
//    delete theKeys;
//    //
//    std::string * obtainedVal = nullptr;
//    for(std::string user_key="start"; 0!=std::string("exit").compare(user_key); )
//    {
//        std::cout <<"\n\t Enter a key (type exit to leave). ";
//        std::cin >> user_key;
//        obtainedVal = cs->getValue( user_key);
//        std::cout<<"\t user_key \t"<< user_key << " value= " << *obtainedVal << std::endl;
//        delete obtainedVal;// because it's NEW at every loop-step.
//    }
//    // ready.
//    delete cs;// del Configuration instance.
//
//
//
////    std::string test = "       Una vita in vacanza pazza       Nel mezzo del cammin di pazza    pazza    pazza pazza nostra vita pazza       Integral massa raggio quadro     ";
////    std::cout << "_";
////    std::cout << test;
////    std::cout << "_" << std::endl;
//
//
//    bool isInvisible = isInvisibleString( test);
//    isInvisible = isInvisibleString( "           ");
//
//    std::cout << "_";
//    std::cout << trimBoth( test);
//    std::cout << "_" << std::endl;
//
//
////
////    std::vector<std::string> * res = stringSplit( "pazza", test );// NB. original passed by value, to be preserved.
////
////    for( std::vector<std::string>::iterator vecPtr=res->begin(); vecPtr!=res->end(); vecPtr++)
////    {
////        std::cout << "\n\t " << *vecPtr << std::endl;
////    }
////    std::cout << "\n######   withNoEmpties   ######\n" << std::endl;
////    std::vector<std::string> * withNoEmpties = stringSplit( "pazza", test, true );// NB. original passed by value, to be preserved.
////    for( std::vector<std::string>::iterator withNoEmptiesPtr=withNoEmpties->begin(); withNoEmptiesPtr!=withNoEmpties->end(); withNoEmptiesPtr++)
////    {
////        std::cout << "\n\t " <<   *withNoEmptiesPtr << std::endl;
////    }
////    std::cout << "\n######   withNoEmpties neither Invisibles  ######\n" << std::endl;
////    for( std::vector<std::string>::iterator withNoEmptiesPtr=withNoEmpties->begin(); withNoEmptiesPtr!=withNoEmpties->end(); withNoEmptiesPtr++)
////    {
////        std::cout << "\n\t " <<   trimBoth(*withNoEmptiesPtr) << std::endl;
////    }
////
////    delete res;
////    delete withNoEmpties;
//
//
//
////    std::string tokenToBeReplaced = "pazza";
////    std::cout << replaceAllOccurencesOf( "pazza", test, "#" ) << std::endl;
//
//
//
////    std::string modif_1 = test.replace( test.find("pazza") , 5, "#");
////    std::cout << modif_1 << std::endl;
////    //
////    std::string modif_2 = test.replace( test.find("pazza") , 5, "#");
////    std::cout << modif_2 << std::endl;
//
//     // Process_LogWrappers::JustConstructTEST("mmm", 0);
//
//    // logTest_monothread_();// mono_thread.
//
//
//	std::string thePath("./AppConfig.txt");
//	std::fstream theStream;
//	//
//    instream_getToken( thePath, theStream);
//
//
//    //OsservatoSpeciale();
//
//
//
//
//    /*
//	std::string thePath("./testConfig20180128_.txt");
//	std::fstream theStream;
//	//
//    instream_getToken( thePath, theStream);
//    */
//
//    /*
//    logTest_monothread_();// mono_thread.
//    //
//    int nThreads = 3;
//    std::thread threads[nThreads];
//    // spawn nThreads threads:
//    for (int i=0; i<nThreads; ++i)
//    {
//        threads[i] = std::thread(EntryPointThreadSpawn_TraceOnly_, i+1);
//    }
//    //
//    for (auto& th : threads)
//    {
//        th.join();
//    }
//    */
//
//
////namespace TestSplit
////{
////
////
////class MemCaleeCaller
////{
////    public:
////    std::vector<std::string> * stringSplit_withAllocation( const std::string &tokenToSplitOn, std::string original, bool removeEmptyEntries )// NB. original passed by value, to be preserved.
////    {
////        unsigned where = 0;
////        unsigned whereWeWere = 0;
////        // the return value is a vector, which contains as many strings, as there are in "original" between the occurences of "tokenToSplitOn".
////        std::vector<std::string> * returnValue = new std::vector<std::string>();
////        // core
////        do// core
////        {
////            where = original.find( tokenToSplitOn);
////            std::string tmp = original.substr( whereWeWere, where );
////            if( true==removeEmptyEntries)
////            {
////                if( false==Common::StrManipul::isInvisibleString( tmp) )
////                {
////                    returnValue->push_back( tmp );
////                }// END if( false==isInvisibleString( tmp) ) : else : skip an emptyEntry.
////            }// END if( true==removeEmptyEntries) : else : do not check for emptyEntries : just push them back along with the other entries.
////            else// else : do not check for emptyEntries : just push them back along with the other entries.
////            {// else : do not check for emptyEntries : just push them back along with the other entries.
////                returnValue->push_back( tmp );
////            }// END else : do not check for emptyEntries : just push them back along with the other entries.
////            original.replace( whereWeWere, where+tokenToSplitOn.size(), "");// eliminate the token that has been detached: do this anyway( i.e. removeEmptyEntries true or false).
////        }// END core
////        while( -1 != where);
////        // ready.
////        return returnValue;
////    }// END stringSplit_withAllocation
////
////
////    std::vector<std::string> & stringSplit_withoutAlloc(
////        const std::string &tokenToSplitOn,
////        std::string original,
////        std::vector<std::string> & preAllocatedReturnVal,
////        bool removeEmptyEntries )// NB. original passed by value, to be preserved.
////    {
////        unsigned where = 0;
////        unsigned whereWeWere = 0;
////        // the return value is a vector, which contains as many strings, as there are in "original" between the occurences of "tokenToSplitOn".
//////std::vector<std::string> * returnValue = new std::vector<std::string>(); NO MORE
////        // core
////        do// core
////        {
////            where = original.find( tokenToSplitOn);
////            std::string tmp = original.substr( whereWeWere, where );
////            if( true==removeEmptyEntries)
////            {
////                if( false==Common::StrManipul::isInvisibleString( tmp) )
////                {
////                    preAllocatedReturnVal.push_back( tmp );
////                }// END if( false==isInvisibleString( tmp) ) : else : skip an emptyEntry.
////            }// END if( true==removeEmptyEntries) : else : do not check for emptyEntries : just push them back along with the other entries.
////            else// else : do not check for emptyEntries : just push them back along with the other entries.
////            {// else : do not check for emptyEntries : just push them back along with the other entries.
////                preAllocatedReturnVal.push_back( tmp );
////            }// END else : do not check for emptyEntries : just push them back along with the other entries.
////            original.replace( whereWeWere, where+tokenToSplitOn.size(), "");// eliminate the token that has been detached: do this anyway( i.e. removeEmptyEntries true or false).
////        }// END core
////        while( -1 != where);
////        // ready.
////        return preAllocatedReturnVal;
////    }// END stringSplit_withoutAlloc
////
////};
////
////}// end nmsp TestSplit
//
////
/////   TODO : cercare il separatore '#'
////    controllare che siano uguali le cardinalita' di key e value
////    predisporre due vector<string> , una per key e una per value (stessa cardinalita' ! )
////    popolare la mappa, mediante le corrispondenze biunivoche [key, value]
////    comportarsi camera sterile
////
////
////bool OsservatoSpeciale()
////{
////    bool result = true; //instreamOpener( fullPath , theInStream );
////    std::fstream theInStream;
////    std::map<std::string, std::string> * this_key_val_map;
////    std::vector<std::string> * this_key_all_together;
////    theInStream.open( "./AppConfig.txt" , std::ios::in );
////    std::vector<std::string> * tokenArray = new std::vector<std::string>;
////    bool this_isHealtlyConstructed = true;
////    //
////    for( int c=0; !theInStream.eof();  )
////    {
////        std::string buf;// tmp for current token.
////        theInStream >> buf;// cosi' va per WORD separate da blank o TAB o new line
////        std::cout<<buf<<std::endl;
////        tokenArray->push_back( buf );
////        ++c;
////    }
////
////    int cardToken = tokenArray->size();// keys + '#' + values : must be n + 1 + n ==2*n+1 so odd (dispari).
////    double ratio = (double)cardToken / 2.0;
////    double fractionalPart = ratio - (int)ratio;
////    if( fabs(fractionalPart) < +1.0E-16 )// was even (pari) -> errore di configurazione (must be 2*n+1).
////    {
////        this_isHealtlyConstructed = false;
////        return (this_isHealtlyConstructed);
////    }// else can continue.
////    int candidateSeparatorPosition = (int)ratio+1;
////    if( ! ((std::string)((*tokenArray)[candidateSeparatorPosition])).compare("#") )
////    {
////        this_isHealtlyConstructed = false;
////        return (this_isHealtlyConstructed);
////    }// else can continue.
////    int c=0;
////    this_key_all_together = new std::vector<std::string>((int)ratio);// how many keys.
////    this_key_val_map = new std::map<std::string, std::string>();
////    int n = (int)ratio;
////    for(std::vector<std::string>::iterator curToken=tokenArray->begin(); curToken!=tokenArray->end(); curToken++)
////    {// indici [c] e [c+n+1] rispettivamente {chiave, valore} nel vector tokenArray.
////        this_key_all_together->push_back( *curToken );// push a key
////        (*(this_key_val_map))[*curToken] = (*(curToken+n+1)).c_str();// push such key together with its corresponding value, in the map.
////        c++;
////        if( n == c)// fondo corsa
////        {
////            break;// keys are over; their corresponfing values, have already been treated.
////        }// else have to continue.
////    }// end for each key.
////    // final usage of bool_result
////    result =instreamCloser( theInStream );
////    result &= (c>0);
////    std::cout<<"\n\n"<<std::endl;
////    for(std::vector<std::string>::iterator curToken=tokenArray->begin(); curToken!=tokenArray->end(); curToken++)
////    {
////        std::cout<<" key = "<< *curToken ;
////        std::cout<<" its value is "<< (*this_key_val_map)[(*curToken).c_str()]<<std::endl;
////        if( ! ((std::string)(*curToken)).compare("#") )
////        {
////            break;// END keys
////        }
////    }
////    std::cout<<"\n\n"<<std::endl;
////    delete tokenArray;
////    //
////    return result;
////}// end  OsservatoSpeciale
//
//
////    bool isConstructorStillAlive = true;
////    //
////    if(isConstructorStillAlive)
////    {// se esiste
////        if(2==2)//(exists)
////        {
////            isConstructorStillAlive = true;
////        }
////        else
////        {
////            isConstructorStillAlive = false;
////        }
////        if(isConstructorStillAlive)
////        {// se riesco ad aprirlo in lettura
////            if(2==2)//(getsOpen_read)
////            {
////                isConstructorStillAlive = true;
////            }
////            else
////            {
////                isConstructorStillAlive = false;
////            }
////            if(isConstructorStillAlive)
////            {// se la sua sintassi e' valida
////                if(2==3)//(has_valid_content)
////                {
////                    isConstructorStillAlive = true;
////                }
////                else
////                {
////                    isConstructorStillAlive = false;
////                }
////                if(isConstructorStillAlive)
////                {// popola la mappa
////                    if(2==2)//if(wasAbleToPopulateTheMap)
////                    {
////                        isConstructorStillAlive = true;
////                    }
////                    else
////                    {
////                        isConstructorStillAlive = false;
////                    }
////                }// END popola la mappa
////            }// END  se la sua sintassi e' valida
////        }// END   se riesco ad aprirlo in lettura
////    }// END  se esiste
////
//
///*
//
//int recursionLevel=0;
//
//void logTest_monothread_()
//{
//    Process_LogWrappers::SectionOpen("void logTest_1()", 0);
//    //
//    while(25>recursionLevel)
//    {
//        ++recursionLevel;
//        std::stringstream sStream;
//        sStream << recursionLevel;
//        std::string LogText("this is some content, logged from inside the current function. Recursion== " + sStream.str() );
//        Process_LogWrappers::SectionContent( LogText.c_str(), 0);
//        logTest_monothread_();
//    }
//    //
//    Process_LogWrappers::SectionClose();
//}
//
//std::mutex open_phase;
//std::mutex trace_phase_1_;
//std::mutex trace_phase_2_;
//std::mutex trace_phase_3_;
//std::mutex close_phase;
//
//void EntryPointThreadSpawn( int par)
//{
//    open_phase.lock();
//    {
//        std::stringstream thread_number_open;
//        thread_number_open << par;
//        //
//        std::vector<std::string> opener;
//        opener.push_back("EntryPointThreadSpawn");
//        opener.push_back(" thread_number= ");
//        opener.push_back(thread_number_open.str());
//        Process_LogWrappers::SectionOpen_multiMessage( opener, 0);
//        opener.clear();
//    }
//    open_phase.unlock();
//    //
//    trace_phase_1_.lock();
//    {
//        std::stringstream thread_number_t1;
//        thread_number_t1 << par;
//        //
//        std::vector<std::string> contentTracer_1;
//        contentTracer_1.push_back("Nel mezzo del cammin di nostra vita");
//        contentTracer_1.push_back(" thread_number= ");
//        contentTracer_1.push_back(thread_number_t1.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_1 , 0);
//        contentTracer_1.clear();
//    }
//    trace_phase_1_.unlock();
//    //
//    trace_phase_2_.lock();
//    {
//        std::stringstream thread_number_t2;
//        thread_number_t2 << par;
//        //
//        std::vector<std::string>  contentTracer_2;
//        contentTracer_2.push_back("Mi ritrovai per una selva oscura");
//        contentTracer_2.push_back(" thread_number= ");
//        contentTracer_2.push_back(thread_number_t2.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_2 , 0);
//        contentTracer_2.clear();
//    }
//    trace_phase_2_.unlock();
//    //
//    trace_phase_3_.lock();
//    {
//        std::stringstream thread_number__t3;
//        thread_number__t3 << par;
//        //
//        std::vector<std::string>  contentTracer_3;
//        contentTracer_3.push_back("che la diritta via era smarrita");
//        contentTracer_3.push_back(" thread_number= ");
//        contentTracer_3.push_back(thread_number__t3.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_3 , 0);
//        contentTracer_3.clear();
//    }
//    trace_phase_3_.unlock();
//    //
//    close_phase.lock();
//    {
//        Process_LogWrappers::SectionClose();
//    }
//    close_phase.unlock();
//    // ready.
//}// END EntryPointThreadSpawn
//
//
//void EntryPointThreadSpawn_TraceOnly_( int par)
//{
//    //
//    trace_phase_1_.lock();
//    {
//        std::stringstream thread_number_t1;
//        thread_number_t1 << par;
//        //
//        std::vector<std::string> contentTracer_1;
//        contentTracer_1.push_back("Nel mezzo del cammin di nostra vita");
//        contentTracer_1.push_back(" thread_number= ");
//        contentTracer_1.push_back(thread_number_t1.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_1 , 0);
//        contentTracer_1.clear();
//    }
//    trace_phase_1_.unlock();
//    //
//    trace_phase_2_.lock();
//    {
//        std::stringstream thread_number_t2;
//        thread_number_t2 << par;
//        //
//        std::vector<std::string>  contentTracer_2;
//        contentTracer_2.push_back("Mi ritrovai per una selva oscura");
//        contentTracer_2.push_back(" thread_number= ");
//        contentTracer_2.push_back(thread_number_t2.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_2 , 0);
//        contentTracer_2.clear();
//    }
//    trace_phase_2_.unlock();
//    //
//    trace_phase_3_.lock();
//    {
//        std::stringstream thread_number__t3;
//        thread_number__t3 << par;
//        //
//        std::vector<std::string>  contentTracer_3;
//        contentTracer_3.push_back("che la diritta via era smarrita");
//        contentTracer_3.push_back(" thread_number= ");
//        contentTracer_3.push_back(thread_number__t3.str());
//        Process_LogWrappers::SectionContent_multiMessage( contentTracer_3 , 0);
//        contentTracer_3.clear();
//    }
//    trace_phase_3_.unlock();
//    // ready.
//}// END EntryPointThreadSpawn_TraceOnly_
//
//
//class SomeClass
//{
//private:
//    int i;
//    char c;
//    char * s;
//    int * ia;
//    std::string stdString;
//
//public:
//    SomeClass()
//    {
//        this->i = 1;
//        this->c = '2';
//        this->s = new char[10];
//        sprintf(this->s,"%s","abc");
//        this->s[3]=0;// terminate.
//        this->ia = new int[3]{1, 2, 3};
//        this->stdString = "this is a STL::string";
//    }
//    SomeClass(
//                    int i_par,
//                    char c_par,
//                    char * s_par,
//                    int * ia_par,
//                    std::string &stdString_par
//              )
//    {
//        this->i = i_par;
//        this->c = c_par;
//        this->s = s_par;
//        this->ia = ia_par;
//        this->stdString = stdString_par;
//    }
//    //
//    SomeClass(
//                bool wantInitList,// NB. #########################
//                    int i_par,
//                    char c_par,
//                    char * s_par,
//                    int * ia_par,
//                    std::string &stdString_par
//              ) :
//        i( i_par)
//        ,c( c_par)
//        ,s( s_par)
//        ,ia( ia_par)
//        ,stdString( stdString_par)
//    {
//    }
//
//};
//
//
////    bool isConstructorStillAlive=true;
////    std::string reasonForNotBeingAlive;
////
////    if(isConstructorStillAlive)
////    {//  first check
////        int i=44;
////        i++;
////        //##
////        if(isConstructorStillAlive)
////        {// check Configuration existence
////            --i;
////            if(3==i)
////            {
////                isConstructorStillAlive=false;
////                reasonForNotBeingAlive = "Configuration existence";
////            }
////            //##
////            if(isConstructorStillAlive)
////            {// check Configuration consistency
////                i+=5;
////                if(3==i)
////                {
////                    isConstructorStillAlive=false;
////                    reasonForNotBeingAlive = "Configuration consistency";
////                }
////                //##
////                if(isConstructorStillAlive)
////                {// check Configuration::semaphore
////                    i=3;
////                    if(3==i)
////                    {
////                        isConstructorStillAlive=false;
////                        reasonForNotBeingAlive = "Configuration::semaphore";
////                    }
////                    //##
////                    if(isConstructorStillAlive)
////                    {// check Configuration::verbosity
////                        if(3==i)
////                        {
////                            isConstructorStillAlive=false;
////                            reasonForNotBeingAlive = "Configuration::verbosity";
////                        }
////                        //##
////                        if(isConstructorStillAlive)
////                        {// check tryOpen
////                            if(3==i)
////                            {
////                                isConstructorStillAlive=false;
////                                reasonForNotBeingAlive = "tryOpen";
////                            }
////                        }// END check tryOpen
////                    }// END check check Configuration::verbosity
////                }// END check Configuration::semaphore
////            }// END check Configuration consistency
////        }// END check Configuration existence
////    }// END first check
//
//
////inline bool FileExists_test( const std::string& name)
////{
////  struct stat buffer;// local variable, whose address is taken to get an output parameter.
////  int result = stat( name.c_str(), &buffer);// NB. buffer contains a lot of interesting fields after the call.
////  bool FileExists = (result==0);
////  return FileExists;
////}
//////bool result = FileExists_test("./LogSinkFsConfig.txt");
//
//
////    // desinenza dinamica per log rotation.
////    time_t now = time(0);// current date/time based on current system
////    char * dynamicEnding = ctime(&now);// convert Operating System date to string form.
////    std::string LogFsName(dynamicEnding);
////    std::string dateStamp(LogFsName.substr(0,11) + LogFsName.substr(20,4) + "_" );
////    std::string timeStamp(LogFsName.substr(11,8) );
////    //
////    std::string traceStamp = dateStamp + timeStamp;
////    std::cout<<"traceStamp = "<<traceStamp<<std::endl;
////    //
//////dayName substr(0,3)
//////month substr(5,3)
//////day substr(8,2)
//////year substr(11,4)
//////    std::string     year = LogFsName.substr(20,4);
//////    std::string     month = LogFsName.substr(20,4)
//////    std::string     day
//////    std::string     hour
//////    std::string     min
//////    std::string     sec
////
////
////    string month = (DateTime.Now.Month  < 10) ? ("0" + DateTime.Now.Month.ToString()  ) : (DateTime.Now.Month.ToString()  );
////    string   day = (DateTime.Now.Day    < 10) ? ("0" + DateTime.Now.Day.ToString()    ) : (DateTime.Now.Day.ToString()    );
////    string hour =  (DateTime.Now.Hour   < 10) ? ("0" + DateTime.Now.Hour.ToString()   ) : (DateTime.Now.Hour.ToString()   );
////    string min  =  (DateTime.Now.Minute < 10) ? ("0" + DateTime.Now.Minute.ToString() ) : (DateTime.Now.Minute.ToString() );
////    string sec  =  (DateTime.Now.Second < 10) ? ("0" + DateTime.Now.Second.ToString() ) : (DateTime.Now.Second.ToString() );
////    string timestamp =
////        DateTime.Now.Year.ToString() +"_"+
////        month +"_"+
////        day +"_"+
////        hour +"_"+
////        min +"_"+
////        sec;
////
//
////                        // current date/time based on current system
////                        time_t now = time(0);
////                        // convert now to string form
////                        char* dynamicEnding = ctime(&now);
////                        printf("\n\tThe local date and time is: %s \n", dynamicEnding);
////                        //std::cout << "The local date and time is: " << dt << endl;
////
////
////                        std::string LogFsName(dynamicEnding);
////                        int * dirtyPositions = new int[LogFsName.length()];
////                        for(int c=0; c<LogFsName.length(); c++)
////                        {
////                            if(32==LogFsName[c])
////                            {
////                                dirtyPositions[c] = 1;// is blank
////                            }
////                            else if(':'==LogFsName[c])
////                            {
////                                dirtyPositions[c] = 2;// is semicolon
////                            }
////                            else if('\n'==LogFsName[c])
////                            {
////                                dirtyPositions[c] = 3;// is new line
////                            }
////                            else
////                            {
////                                dirtyPositions[c] = 0;// is OK.
////                            }
////                        }
////                        for(int c=0; c<LogFsName.length(); c++)
////                        {
////                            if(1==dirtyPositions[c])// is blank
////                            {
////                                LogFsName[c] = '_';
////                            }
////                            else if(2==dirtyPositions[c])// is semicolon
////                            {
////                                LogFsName[c] = '#';
////                            }
////                            else if(3==dirtyPositions[c])// is new line
////                            {
////                                LogFsName[c] = '_';// eliminate the new line.
////                            }// else  is NOT blank : leave it.
////                        }
////                        delete[] dirtyPositions;
////
////                        printf("\n\tThe local date and time is: %s \n", LogFsName.c_str() );
////                        delete[] dynamicEnding;
//
//
////Map_managment();
//
////StringStream_exercise();
//
////TestTSingleonWrapper();
//
////      ---- binary tree -----
////    char * dataFilePath = (char *)calloc( 100, sizeof(char) ) ;
////    sprintf(dataFilePath, "./treeData.txt");
////    int treeRes = BinTree_wrapper_C_( dataFilePath );
////    // on re-entry :
////    free( dataFilePath);
//
//
//void fReader_byString()
//{
//   std::ifstream dumpReader( "./PrimeIntegral_fromOrigin_.txt", std::fstream::in );// read-only.
//   dumpReader.seekg( 0, dumpReader.end);
//   long dumpSize = dumpReader.tellg();
//   dumpReader.seekg( dumpSize/2, dumpReader.beg );
//   int bufSize = 80;
//   char * buf = nullptr;
//   for( ; !dumpReader.eof() && dumpSize>bufSize; )
//   {
//       dumpSize = dumpReader.tellg();
//       bufSize = dumpSize/2;//adaptive.
//       buf = new char[bufSize];
//       dumpReader.read( buf, bufSize-1);
//       buf[bufSize-1]=0;
//       dumpReader.seekg( dumpSize/2, dumpReader.beg );
//       std::cout << buf << std::endl;
//       delete[] buf;
//   }
//   dumpReader.close();
//}// fReader_byString
//
//
//
//void fReader_byRow()
//{
//   std::ifstream dumpReader( "./PrimeIntegral_fromOrigin_.txt", std::fstream::in );// read-only.
//   dumpReader.clear();
//   dumpReader.seekg(0, ios::beg);// from start
//   int bufSize = 20;
//   char buf[bufSize];
//   for( ; !dumpReader.eof(); )
//   {
//       dumpReader.getline( buf, bufSize-1,'\r');
//       buf[bufSize-1]=0;
//       std::cout << buf << std::endl;
//   }
//   dumpReader.close();
//}// fReader_byRow
//
////NB.////dumpReader.clear();
////dumpReader.seekg( bufSize, ios::beg);// from start
//
//
//
//unsigned long factorial( unsigned int par)
//{
//    unsigned long res = +1UL;
//    for( int c=par; c>+1; c--)
//    {
//        res *= c;
//    }
//    return res;
//}// factorial
//
//double factorial( unsigned int par, bool onReals)
//{
//    double res = +1.0;
//    for( int c=par; c>+1; c--)
//    {
//        res *= c;
//    }
//    return res;
//}// factorial
//
//
//// TODO: verificare convergenza, per zone del piano complesso.
//Numerics::Complex ExpIntegralEi_Ramanujan( Numerics::Complex zVariable)
//{/* notes on a convergent series:
//    N[(+EulerGamma + Log[zVariable]) +
//    Exp[zVariable/2]*Sum[((-1)^(n - 1) (zVariable)^n)/((n!)*(2^(n - 1)))*
//    Sum[+1/(2*k + 1), {k, 0, Floor[(n - 1)/2]}], {n, +1, +99}]]
//    */
//    const double EulerGamma = +0.577216;// Euler-Mascheroni.
//    Numerics::Complex externalAddend(0.0, 0.0);// init to zero the Sum element. The external one is never updated.
//    Numerics::Complex internalFactor(+1.0, 0.0);// the internal one is a factor and gets reset at each external-loop.
//    //
//    for( int n=+1; n<=+12; n++)// NB. ######## factorial does not support (now) more than 12! ######
//    {
//        for(int k=0; k< floor(((double)n - 1.0)/2.0); k++ )
//        {
//            internalFactor += +1.0/(2.0*(double)k + 1.0);
//        }// end internal-factor finite sum.
//        externalAddend += (zVariable^n)*pow((-1.0),((double)n - 1.0))  /(factorial(n,true)* pow(2.0,((double)n - 1)) ) * internalFactor;
//        internalFactor = +1.0;// reset.
//    }// end external series step.
//    externalAddend += zVariable.LnC() + EulerGamma;// final addenda.
//    // ready.
//    return externalAddend;
//}// Ramanujan series
//
//
//double fFormExpIntegralE1_Re( double u
// ,double x, double y )// these last ones have to be constant, since they are Re and Im of the complex param.
//{
//    return exp(-x/u)*cos(y/u)/u;
//}
//
//double fFormExpIntegralE1_Im( double u
// ,double x, double y )// these last ones have to be constant, since they are Re and Im of the complex param.
//{
//    return -exp(-x/u)*sin(y/u)/u;
//}
//
//double EunoWrapper_RealPart;
//double EunoWrapper_ImmaginaryPart;
//double EunoWrapper_Re( double u)
//{
//    return fFormExpIntegralE1_Re( u,EunoWrapper_RealPart,EunoWrapper_ImmaginaryPart);
//}//EunoWrapper_Re
//double EunoWrapper_Im( double u)
//{
//    return fFormExpIntegralE1_Im( u,EunoWrapper_RealPart,EunoWrapper_ImmaginaryPart);
//}//EunoWrapper_Im
//
//
//Numerics::Complex EunoZeta( Numerics::Complex zVariable)
//{/*
//ComplexExpand[ Exp[-(x + I*y)/u]/u] ==
//                (\[ExponentialE]^(-(x/u))*Cos[y/u])/u +
//- (\[ImaginaryI] \[ExponentialE]^(-(x/u)) Sin[y/u])/u     ==
//==              (E^(-(x/u))*Cos[y/u])/u +
//- (\[ImaginaryI]*E^(-(x/u))*Sin[y/u])/u      ==
//== (E^(-(x/u))*Cos[y/u])/u - (I*E^(-(x/u))*Sin[y/u])/u ==
//== (E^(-(x/u)))/u*(Cos[y/u]-(I*Sin[y/u]) ==
//== (E^(-(x/u)))/u*(E^(-I*(y/u)))
//    */
//    //
//    EunoWrapper_RealPart = zVariable.Re();
//    EunoWrapper_ImmaginaryPart = zVariable.Im();
//    Entity::Integration::FunctionalForm f_Re = EunoWrapper_Re;// function pointer to wrapper for Real_part.
//    Entity::Integration::FunctionalForm f_Im = EunoWrapper_Im;// function pointer to wrapper for Immaginary_part.
//    // integrate in du , u in (0,+1)
//    double RealPart = Entity::Integration::trapezi( 0.0, +1.0, 999, f_Re);
//    Numerics::Complex res( Entity::Integration::trapezi( 0.03, +1.0, 999, f_Re)
//                              , Entity::Integration::trapezi( 0.03, +1.0, 999, f_Im) );
//    //ready.
//    return res;
//}// EunoZeta
//
//
//    Numerics::Complex zVariable( +33.0, 1952.0 );
//    const double dx = +1.0E-3;
//    for( double u=0.03; u<=+0.97; u+=dx)
//    {
//        double re = fFormExpIntegralE1_Re( u, zVariable.Re(), zVariable.Im() );
//        double im = fFormExpIntegralE1_Im( u, zVariable.Re(), zVariable.Im() );
//        std::cout<<"\n\t fFormExpIntegralE1_xx( "<<u<<", "<< zVariable.Re() <<" +I* "<< zVariable.Im() <<")==" << re <<" +I* "<< im <<std::endl;
//    }
//
//    Numerics::Complex res = EunoZeta( zVariable);
//    std::cout<<"\n\t Euno( "<< zVariable.Re() <<" +I* "<< zVariable.Im() <<")==" << res.Re() <<" +I* "<< res.Im() <<std::endl;

//    Numerics::Complex zVariable( +33.0, 1952.0 );
//    Numerics::Complex res = ExpIntegralEi_Ramanujan( zVariable);
//    std::cout<<"\n\t ExpIntegralEi_Ramanujan( "<< zVariable.Re() <<" +I* "<< zVariable.Im() <<")==" << res.Re() <<" +I* "<< res.Im() <<std::endl;

//    for( int c=0; c<19; c++)
//    {
//        std::cout<<"\n\tFactorial("<<c<<")=="<<factorial(c)<<std::endl;
//        std::cout<<"\n\tFactorial("<<c<<")=="<<factorial(c, true)<<std::endl;
//    }
//
//    struct SingleFactor
//    {
//        unsigned long  pi;
//        unsigned long  ai;
//    };
//
//SingleFactor * protoFactorize( unsigned long par)
//{
//    SingleFactor * factorization = new SingleFactor[100];// TODO #
//    unsigned long sogliaStimata = par/2;// greatest involved-prime is the cofactor of the smallest one(i.e. 2).
//    // ordinaleStimato == LogIntegral[ sogliaStimata] NB. overstimate it, for safety.
////        Entity::Integration::FunctionalForm LogIntegral = LogIntegral_coChain;// function pointer.
////        double LogIntegral_ofInfPar = Entity::Integration::trapezi( +2.0, (double)infLeft, ((double)infLeft-2.0)*4, LogIntegral );
////     unsigned ordinaleStimato = (unsigned long)LogIntegral_ofInfPar;//TODO stima !
//    unsigned ordinaleStimato = 11UL; // TODO
//    for(int c=0; c<ordinaleStimato; c++)
//    {// init.
//        factorization[c].pi = 0;
//        factorization[c].ai = 0;
//    }
//    // TODO readRange( 1, ordinaleStimato);
//    unsigned long * involvedPrimes = new unsigned long[ordinaleStimato]{2,3,5,7,11,13,17,19,23,29,31};
//    unsigned long dividendo, divisore;
//    dividendo = par;
//    double realQuotient;
//    unsigned long intQuotient;
//    int i=0;// start from +2. indice nel vettore dei primi.
//    int acc=0;// indice nel vettore dei risultati.
//    divisore=involvedPrimes[i];
//    bool lastDivisionWasDiophantine =  false;
//    double soglia = (double)dividendo/2.0; // greatest involved-prime is the cofactor of the smallest one(i.e. 2).
//    //
//    for(  ; +1<dividendo; )
//    {
//        realQuotient = (double)dividendo/(double)divisore;
//        intQuotient = dividendo/divisore;
//        if( realQuotient-intQuotient <+1.0E-80 )// ####### ramo lastDivisionWasDiophantine ##
//        {// divisione diofantea : the prime acting as divisor is a factor (i.e. divides dividendo).
//            if(  lastDivisionWasDiophantine)
//            {
//                // factorization[acc].pi is already correct: do nothing.
//                factorization[acc].ai++;// increment ai on this pi
//                lastDivisionWasDiophantine =  true;
//            }
//            else if( ! lastDivisionWasDiophantine)
//            {
//                factorization[acc].pi = divisore;// promote current prime and its exponent.
//                factorization[acc].ai++;// increment ai on this pi
//                lastDivisionWasDiophantine =  true;
//            }// No other else.
//            // in common btw curDivDiophantine
//            dividendo = intQuotient;// NB. swap the dividendo, after a successful
//        }// if // divisione diofantea : the prime acting as divisor is a factor (i.e. divides dividendo).
//        else// ### no Diophantine division ##
//        {// else: goto test next prime, as divisor.
//            if(  lastDivisionWasDiophantine)
//            {
//                acc++;// next factor slot, in the results array.
//            }
//            else if( ! lastDivisionWasDiophantine)
//            {
//                // NO acc++ we don't have an idoneous factor, yet.
//            }// No other else.
//            // factors in common btw lastDivisionWasDiophantine when curDivNOTDiophantine
//            i++;// test next prime, as factor.
//            lastDivisionWasDiophantine =  false;
//            divisore=involvedPrimes[i];// to next prime, if cur one works no more
//        }// else// ### no Diophantine division ##
//    }
//    //..
//    delete[] involvedPrimes;
//    // ready.
//    return factorization;// NB. the caller has to delete.
//}// protoFactorize
